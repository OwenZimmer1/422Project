/**
* Gets the location.
*
* @return the current location
*/
public Point getLoc(){return location;}

/**
* Gets the radius.
*
* @return the radius
*/
public int getRadius(){return radius;}

/**
* Return the current movement of the ball.
*
* @return the current movement
*/
public Vector getMove(){return move;}

/**
* Set the radius of this ball.
* @param r new radius, must be positive.
*/
public void setRadius(int r) {
if (r <= 0) throw new IllegalArgumentException("radius must be positive, not " + r);
radius = r;
}

/**
* Launches the ball by setting active to true.
*/
public void launch(){active=true;}


/**
* If ball is active: moves location by the current movement.
* If ball is not active: rotates vector by Math.PI/24.
*/
public void step(){
if(active == true) {
double x = this.getLoc().x() + this.getMove().dx();
double y = this.getLoc().y() + this.getMove().dy();
this.location = new Point(x, y);
}
else
this.move = this.getMove().rotate(Math.PI/24);
}


/**
* Checks if ball is at or outside BOUNDS dimension and moving further out,
* and reflects movement if so.  If the ball isn't moving further out, the
* movement isn't reflected.
* @param bounds dimension of area to check (all four walls), must not be null
*/
public void bounceWalls(Dimension bounds) {
if((this.getLoc().x() + this.getRadius() >= bounds.getWidth()) && this.getMove().dx() > 0)
this.move = new Vector(-1*this.getMove().dx(), this.getMove().dy());
if((this.getLoc().y() + this.getRadius() >= bounds.getHeight()) && this.getMove().dy() > 0)
this.move = new Vector(this.getMove().dx(), -1*this.getMove().dy());
if((this.getLoc().x() - this.getRadius() <= 0) && this.getMove().dx() < 0)
this.move = new Vector(-1*this.getMove().dx(), this.getMove().dy());
if((this.getLoc().y() - this.getRadius() <= 0) && this.getMove().dy() < 0)
this.move = new Vector(this.getMove().dx(), -1*this.getMove().dy());

}

/**
* Checks if colliding with the parameter ball.
*
* @param other the other ball
* @return true if colliding
*/
public boolean isColliding(Ball other){
return this.getLoc().distance(other.getLoc()) <= this.getRadius() + other.getRadius();
}

/**
* Calculates new vectors for this and the parameter ball using normal and
* tangent vectors, then calls step() on both until no longer colliding.
*
* @param other the other ball
*/
public void bounce(Ball other){
Vector my_unit_normal = new Vector(location, other.getLoc()).normalize();
Vector other_unit_normal = new Vector(other.getLoc(), location).normalize();
Vector my_normal = my_unit_normal.scale(move.dot(my_unit_normal));
Vector other_normal = other_unit_normal.scale(other.move.dot(other_unit_normal));
Vector my_tangent = move.add(my_normal.scale(-1));
Vector other_tangent = other.move.add(other_normal.scale(-1));

move = my_tangent.add(other_normal);
other.move = other_tangent.add(my_normal);

while (isColliding(other)){
step();
other.step();}
}

/**
* Draws the ball, and if non-active also draws its vector.
*
* @param g the Graphics context on which to draw
*/
public void draw(Graphics g){
g.setColor(color);
g.fillOval(location.intX() - radius, location.intY() - radius, radius * 2, radius * 2);
if (!active){
Vector standard_vec = move.normalize().scale(radius * 2);
g.setColor(Color.RED);
g.drawLine(location.intX(), location.intY(), standard_vec.move(location).intX(), standard_vec.move(location).intY());
}
}

/* Make a Ball with the same features as this ball.
* @see java.lang.Object#clone()
*/
@Override
public Ball clone() {
try {
return (Ball)super.clone();
}catch (CloneNotSupportedException cnse) {
throw new RuntimeException
("This class does not Implament Cloneable");
}

}

/**
* gets x value
*
* @return current x value
*/
public double x() {
return this.x;
}

/**
* gets y value
*
* @return current y value
*/
public double y() {
return this.y;
}

/**
* gets x value to nearest integer
*
* @return x value to nearest integer
*/
public int intX() {
return (int)Math.round(this.x());
}

/**
* gets y value to nearest integer
*
* @return y value to nearest integer
*/
public int intY() {
return (int)Math.round(this.y());
}

/**
* finds the distance between 2 points
*
* @param point the point that will be found the distance from
* @return the distance between two points
*/
public double distance(Point point) {
Vector temp = new Vector(this, point);
return temp.magnitude();
}

/**
* Instantiates a new vector with specified delta values.
*
* @param dx the initial deltax value
* @param dy the initial deltay value
*/
public Vector(double dx, double dy){
this.deltax = dx;
this.deltay = dy;
}

/**
* Instantiates a new unit vector with specified angle.
*
* @param theta the angle to construct, in radians
*/
public Vector(double theta){
this.deltax = Math.cos(theta);
this.deltay = Math.sin(theta);
}

/**
* Instantiates a new vector between two points.
* If applied to the first point, the result is the second point.
*
* @param p the first point
* @param q the second point
*/
public Vector(Point p, Point q){
this.deltax = q.x() - p.x();
this.deltay = q.y() - p.y();
}

/**
* Getter for deltax field.
*
* @return the current deltax value
*/
public double dx(){
return this.deltax;
}

/**
* Getter for deltay field.
*
* @return the current deltay value
*/
public double dy(){
return this.deltay;
}

/**
* Translates the parameter point by this vector.
*
* @param p the point to translate
* @return the  translated point
*/
public Point move(Point p){
return new Point(p.x() + this.dx(), p.y() + this.dy());
}

/**
* Adds the parameter vector with this vector.
*
* @param v the vector to add
* @return the vector sum
*/
public Vector add(Vector v){
return new Vector(this.dx() + v.dx(), this.dy() + v.dy());
}

/**
* Takes the dot product of this vector and the parameter vector.
*
* @param v the other vector
* @return the dot product
*/
public double dot(Vector v){
return this.dx() * v.dx() + this.dy() * v.dy();
}

/**
* Scales this vector by the parameter.
*
* @param s the constant to scale by
* @return the scaled vector
*/
public Vector scale(double s){
return new Vector(s * this.dx(), s * this.dy());
}

/**
* Finds the magnitude of this vector.
*
* @return how long this vector is (never negative).
*/
public double magnitude(){
double temp = this.dx() * this.dx() + this.dy() * this.dy();
return Math.sqrt(temp);
}

/**
* Normalizes this vector.
*
* @return a vector with the same angle but magnitude of one.
*/
public Vector normalize(){
double magnitude = this.magnitude();
return new Vector(this.dx() / magnitude, this.dy() / magnitude);
}

/**
* gets angle theta
*
* @return angle of vector off x axis
*/
public double theta() {

if(this.dx() == 0 && this.dy() > 0)
return Math.PI/2;
else if(this.dx() == 0)
return Math.PI * 3 / 2;

double theta = Math.atan(this.dy() / this.dx());
if(this.dx() < 0)
theta += Math.PI;
return theta;
}

/**
* Rotates this vector clockwise by the parameter angle (in radians).
*
* @param theta the angle to rotate (in radians)
* @return the rotated vector
*/
public Vector rotate(double theta){
double angle = this.theta() + theta;
Vector v = new Vector(angle);
return v.scale(this.magnitude());
}

/**
* Compute the angle of this vector, in radians,
* clockwise from the x-axis.
*
* @return the angle in range [0,2Pi)
*/
public double angle() {
double magn = magnitude();
if (magn == 0.0) return 0;
double alpha = Math.acos(dx()/magn);
if(dy() < 0) alpha = 2*Math.PI-alpha;
return alpha;
}

/**
* Initialize an empty sequence with an initial capacity of INITIAL_CAPACITY.
* The append method works
* efficiently (without needing more memory) until this capacity is reached.
* @param - none
* @postcondition
*   This sequence is empty and has an initial capacity of INITIAL_CAPACITY
* @exception OutOfMemoryError
*   Indicates insufficient memory for initial array.
**/
public BallSeq( )
{
this(INITIAL_CAPACITY);
assert wellFormed() : "Invariant false at end of constructor";
}

/**
* Initialize an empty sequence with a specified initial capacity. Note that
* the append method works
* efficiently (without needing more memory) until this capacity is reached.
* @param initialCapacity
*   the initial capacity of this sequence
* @precondition
*   initialCapacity is non-negative.
* @postcondition
*   This sequence is empty and has the given initial capacity.
* @exception IllegalArgumentException
*   Indicates that initialCapacity is negative.
* @exception OutOfMemoryError
*   Indicates insufficient memory for an array with this many elements.
*   new Ball[initialCapacity].
**/
public BallSeq(int initialCapacity)
{
if(initialCapacity < 0) throw new IllegalArgumentException("Inital Capacity must be non-negative");

data = new Ball[initialCapacity];
manyItems = 0;
currentIndex = 0;
assert wellFormed() : "Invariant false at end of constructor";
}

/**
* Determine the number of elements in this sequence.
* @param - none
* @return
*   the number of elements in this sequence
**/
public int size( )
{
assert wellFormed() : "invariant failed at start of size";

return manyItems;
}

/**
* The first element (if any) of this sequence is now current.
* @param - none
* @postcondition
*   The front element of this sequence (if any) is now the current element (but
*   if this sequence has no elements at all, then there is no current
*   element).
**/
public void start( )
{
assert wellFormed() : "invariant failed at start of start";

currentIndex = 0;
assert wellFormed() : "invariant failed at end of start";
}

/**
* Accessor method to determine whether this sequence has a specified
* current element (a Ball or null) that can be retrieved with the
* getCurrent method. This depends on the status of the cursor.
* @param - none
* @return
*   true (there is a current element) or false (there is no current element at the moment)
**/
public boolean isCurrent( )
{
assert wellFormed() : "invariant failed at start of isCurrent";

return currentIndex < manyItems;
}

/**
* Accessor method to get the current element of this sequence.
* @param - none
* @precondition
*   isCurrent() returns true.
* @return
*   the current element of this sequence, possibly null
* @exception IllegalStateException
*   Indicates that there is no current element, so
*   getCurrent may not be called.
**/
public Ball getCurrent( )
{
assert wellFormed() : "invariant failed at start of getCurrent";

if(!isCurrent()) throw new IllegalStateException("No current element found");

return data[currentIndex];

}

/**
* Move forward, so that the next element is now the current element in
* this sequence.
* @param - none
* @precondition
*   isCurrent() returns true.
* @postcondition
*   If the current element was already the end element of this sequence
*   (with nothing after it), then there is no longer any current element.
*   Otherwise, the new current element is the element immediately after the
*   original current element.
* @exception IllegalStateException
*   If there was no current element, so
*   advance may not be called (the precondition was false).
**/
public void advance( )
{
assert wellFormed() : "invariant failed at start of advance";

if(!isCurrent()) throw new IllegalStateException("Can not advance");
if(data.length > currentIndex)
currentIndex++;

assert wellFormed() : "invariant failed at end of advance";
}

/**
* Remove the current element from this sequence.
* @param - none
* @precondition
*   isCurrent() returns true.
* @postcondition
*   The current element has been removed from this sequence, and the
*   following element (if there is one) is now the new current element.
*   If there was no following element, then there is now no current
*   element.
* @exception IllegalStateException
*   Indicates that there is no current element, so
*   removeCurrent may not be called.
**/
public void removeCurrent( )
{
assert wellFormed() : "invariant failed at start of removeCurrent";

if(!isCurrent()) throw new IllegalStateException("No current element");


for(int i = currentIndex; i < manyItems-1; i++) {
data[i] = data[i+1];
}
data[manyItems-1] = null;
manyItems--;
assert wellFormed() : "invariant failed at end of removeCurrent";
}

/**
* Change the current capacity of this sequence if needed.
* @param minimumCapacity
*   the new capacity for this sequence
* @postcondition
*   This sequence's capacity has been changed to at least minimumCapacity.
*   If the capacity was already at or greater than minimumCapacity,
*   then the capacity is left unchanged.
*   If the capacity is changed, it must be at least twice as big as before.
* @exception OutOfMemoryError
*   Indicates insufficient memory for: new array of minimumCapacity elements.
**/
private void ensureCapacity(int minimumCapacity)
{
if(data.length >= minimumCapacity) return;

int newSize = data.length * 2;
if (newSize < minimumCapacity) newSize = minimumCapacity;

Ball[] newArray = new Ball[newSize];
for(int i = 0; i < data.length; i++) {
newArray[i] = data[i];
}
data = newArray;
}

/**
* Add a new element to this sequence, before the current element (if any).
* If the new element would take this sequence beyond its current capacity,
* then the capacity is increased before adding the new element.
* @param element
*   the new element that is being added
* @postcondition
*   A new copy of the element has been added to this sequence. If there was
*   a current element, then the new element is placed before the current
*   element. If there was no current element, then the new element is placed
*   at the end of the sequence. In all cases, the new element becomes the
*   new current element of this sequence.
* @exception OutOfMemoryError
*   Indicates insufficient memory for increasing the sequence's capacity.
**/
public void insert(Ball element)
{
assert wellFormed() : "invariant failed at start of insert";

ensureCapacity(manyItems + 1);

for(int i = manyItems; i > currentIndex; i--) {
data[i] = data[i-1];
}
data[currentIndex] = element;

manyItems++;

assert wellFormed() : "invariant failed at end of insert";
}

/**
* Place the contents of another sequence (which may be the
* same one as this!) into this sequence before the current element (if any).
* @param addend
*   a sequence whose contents will be placed into this sequence
* @precondition
*   The parameter, addend, is not null.
* @postcondition
*   The elements from addend have been placed into
*   this sequence. The current element of this sequence (if any)
*   is unchanged.  The addend is unchanged.
* @exception NullPointerException
*   Indicates that addend is null.
* @exception OutOfMemoryError
*   Indicates insufficient memory to increase the size of this sequence.
**/
public void insertAll(BallSeq addend) {
assert wellFormed() : "invariant failed at start of addAll";

if(addend == null) throw new NullPointerException("Sequence is null");

BallSeq clone = addend.clone();
ensureCapacity(manyItems + clone.manyItems);
int indexInc = clone.manyItems;
for(int i = clone.manyItems - 1; i >= 0; i--) {
insert(clone.data[i]);
}

currentIndex += indexInc;


assert wellFormed() : "invariant failed at end of addAll";
}

/**
* Generate a copy of this sequence.
* @param - none
* @return
*   The return value is a copy of this sequence. Subsequent changes to the
*   copy will not affect the original, nor vice versa.
* @exception OutOfMemoryError
*   Indicates insufficient memory for creating the clone.
**/
public BallSeq clone( )
{  // Clone a BallSeq object.
assert wellFormed() : "invariant failed at start of clone";
BallSeq answer = new BallSeq(manyItems);

answer.currentIndex = currentIndex;
answer.manyItems = manyItems;

for(int i = 0; i < manyItems; i++) {
answer.data[i] = data[i];
}

assert wellFormed() : "invariant failed at end of clone";
assert answer.wellFormed() : "invariant failed for clone";

return answer;
}

/**
* default constructor for default capacity of zero
*/
public BallCollection() {
this(INITIAL_CAPACITY);
}

/**
* constructor
* @param manyItems: number of items
*/
public BallCollection(int manyItems) {
data = new Ball[manyItems];
this.manyItems = manyItems;
version = 0;

assert wellFormed() : "invariant failed at end of constructor";
}

/**
* Instantiates a new player.
*
* @param loc the initial location
*/
public Player(Point loc){location=loc;radius = DodgeBall.PLAYER_RADIUS;}

/**
* Sets the current image.
*
* @param img the new player image
*/
public void setImg(BufferedImage img){playerImg = img;}

/**
* Increases the player's radius.
*
* @see DodgeBall.makeHarder()
*/
public void grow(){radius += 2;}

/**
* Checks if colliding with parameter ball.
*
* @param b the ball
* @return true if colliding
*/
public boolean isColliding(Ball b){
return DodgeBall.MORTAL && location.distance(b.getLoc()) <= (radius + b.getRadius());}

/**
* Update the player's location.
*
* @param mouseLoc the current [adjusted] mouse location
*/
public void update(Point mouseLoc){
int new_x = Math.max(radius, mouseLoc.intX());
int new_y = Math.max(radius, mouseLoc.intY());
new_x = Math.min(new_x, DodgeBall.BOUNDS.width -radius);
new_y = Math.min(new_y, DodgeBall.BOUNDS.height - radius);
location = new Point(new_x, new_y);
}

/**
* Draws the player.
*
* @param g the Graphics context on which to draw
*/
public void draw(Graphics g){
g.drawImage(playerImg,
location.intX() - radius, location.intY() - radius,
radius*2, radius*2, null);
}

/**
* Create an empty sequence
* @param - none
* @postcondition
*   This sequence is empty
**/
public BallSeq( )
{
manyNodes = 0;
head = null;
tail = null;
cursor = null;
precursor = null;

assert wellFormed() : "invariant failed in constructor";
}

/**
* Determine the number of elements in this sequence.
* @param - none
* @return
*   the number of elements in this sequence
**/
public int size( )
{
assert wellFormed() : "invariant wrong at start of size()";

return manyNodes;
}

/**
* Set the current element at the front of this sequence.
* @param - none
* @postcondition
*   The front element of this sequence is now the current element (but
*   if this sequence has no elements at all, then there is no current
*   element).
**/
public void start( )
{
assert wellFormed() : "invariant wrong at start of start()";

cursor = head;
precursor = null;

assert wellFormed() : "invariant wrong at end of start()";
}

/**
* Accessor method to determine whether this sequence has a specified
* current element that can be retrieved with the
* getCurrent method.
* @param - none
* @return
*   true (there is a current element) or false (there is no current element at the moment)
**/
public boolean isCurrent( )
{
assert wellFormed() : "invariant wrong at start of getCurrent()";
// TODO: Implemented by student.
// This method shouldn't modify any fields, hence no assertion at end
return cursor != null;
}

/**
* Accessor method to get the current element of this sequence.
* @param - none
* @precondition
*   isCurrent() returns true.
* @return
*   the current element of this sequence
* @exception IllegalStateException
*   Indicates that there is no current element, so
*   getCurrent may not be called.
**/
public Ball getCurrent( )
{
assert wellFormed() : "invariant wrong at start of getCurrent()";
if(!isCurrent()) throw new IllegalStateException("no current element");

return cursor.data;
}

/**
* Move forward, so that the current element is now the next element in
* this sequence.
* @param - none
* @precondition
*   isCurrent() returns true.
* @postcondition
*   If the current element was already the end element of this sequence
*   (with nothing after it), then there is no longer any current element.
*   Otherwise, the new element is the element immediately after the
*   original current element.
* @exception IllegalStateException
*   Indicates that there is no current element, so
*   advance may not be called.
**/
public void advance( )
{
assert wellFormed() : "invariant wrong at start of advance()";
if(!isCurrent()) throw new IllegalStateException("no current element");

if(cursor.next != null) {
precursor = cursor;
cursor = cursor.next;
}
else {
cursor = null;
precursor = null;
}
assert wellFormed() : "invariant wrong at end of advance()";
}

/**
* Remove the current element from this sequence.
* @param - none
* @precondition
*   isCurrent() returns true.
* @postcondition
*   The current element has been removed from this sequence, and the
*   following element (if there is one) is now the new current element.
*   If there was no following element, then there is now no current
*   element.
* @exception IllegalStateException
*   Indicates that there is no current element, so
*   removeCurrent may not be called.
**/
public void removeCurrent( )
{
assert wellFormed() : "invariant wrong at start of removeCurrent()";
if(!isCurrent()) throw new IllegalStateException("no element to remove");
// TODO: Implemented by student.
// See textbook pp.176-78, 181-184
if(manyNodes == 1) {
head = null;
tail = null;
precursor = null;
cursor = null;
}
else if(cursor == tail) {
tail = precursor;
tail.next = null;
precursor = null;
cursor = null;
}
else if(cursor == head) {
head = head.next;
cursor = head;
}
else {
cursor = cursor.next;
precursor.next = cursor;
}
manyNodes--;

assert wellFormed() : "invariant wrong at end of removeCurrent()";
}

/**
* Add a new element to this sequence, before the current element (if any).
* If the new element would take this sequence beyond its current capacity,
* then the capacity is increased before adding the new element.
* @param element
*   the new element that is being added
* @postcondition
*   A new copy of the element has been added to this sequence. If there was
*   a current element, then the new element is placed before the current
*   element. If there was no current element, then the new element is placed
*   at the end of the sequence. In all cases, the new element becomes the
*   new current element of this sequence.
* @exception OutOfMemoryError
*   Indicates insufficient memory for increasing the sequence.
**/
public void insert(Ball element)
{
assert wellFormed() : "invariant failed at start of insert";

if(manyNodes == 0) {
cursor = new Node(element, cursor);
tail = cursor;
head = cursor;
}
else if(cursor == head){
cursor = new Node(element, cursor);
head = cursor;
}
else if(cursor == null) {
tail.next = new Node(element, null);
precursor = tail;
tail = tail.next;
cursor = tail;
}else {
cursor = new Node(element, cursor);
precursor.next = cursor;
}

manyNodes++;

assert wellFormed() : "invariant failed at end of insert";
}

/**
* Place the contents of another sequence (which may be the
* same one as this!) into this sequence before the current element (if any).
* @param addend
*   a sequence whose contents will be placed into this sequence
* @precondition
*   The parameter, addend, is not null.
* @postcondition
*   The elements from addend have been placed into
*   this sequence. The current element of this sequence (if any)
*   is unchanged.  The addend is unchanged.
* @exception NullPointerException
*   Indicates that addend is null.
* @exception OutOfMemoryError
*   Indicates insufficient memory to increase the size of this sequence.
**/
public void insertAll(BallSeq addend) {
assert wellFormed() : "invariant failed at start of addAll";
if(addend == null) throw new NullPointerException("addend is null");

if(addend.head == null) return;
BallSeq clone = addend.clone();

if(manyNodes == 0) {
head = clone.head;
tail = clone.tail;
}
else if (cursor == head){
head = clone.head;
clone.tail.next = cursor;
precursor = clone.tail;
}
else if (cursor == null) {
tail.next = clone.head;
tail = clone.tail;
}
else {
precursor.next = clone.head;
precursor = clone.tail;
clone.tail.next = cursor;
}
manyNodes += clone.manyNodes;

assert wellFormed() : "invariant failed at end of addAll";
}

/**
* Generate a copy of this sequence.
* @param - none
* @return
*   The return value is a copy of this sequence. Subsequent changes to the
*   copy will not affect the original, nor vice versa.
*   Whatever was current in the original object is now current in the clone.
* @exception OutOfMemoryError
*   Indicates insufficient memory for creating the clone.
**/
public BallSeq clone( )
{
assert wellFormed() : "invariant wrong at start of clone()";

BallSeq result;

try
{
result = (BallSeq) super.clone( );
}
catch (CloneNotSupportedException e)
{
// This exception should not occur. But if it does, it would probably
// indicate a programming error that made super.clone unavailable.
// The most common error would be forgetting the "Implements Cloneable"
// clause at the start of this class.
throw new RuntimeException
("This class does not implement Cloneable");
}
// This is inspired by the textbook for this class, page 203
if(result.head == null) return result;

Node source = result.head;
Node copyHead = new Node(source.data, null);
Node copyTail = copyHead;

while(source.next != null) {
if(source == cursor) result.cursor = copyTail;
if(source == precursor) result.precursor = copyTail;
if(source == tail) result.tail = source;
source = source.next;
copyTail.next = new Node(source.data, null);
copyTail = copyTail.next;
}
result.head = copyHead;
if(source == cursor) result.cursor = copyTail;
if(source == precursor) result.precursor = copyTail;
if(source == tail) result.tail = copyTail;

// TODO: Implemented by student.
// Now do the hard work of cloning the list.
// See pp 200-204, 235 (3rd ed. pp. 193-197, 228)
// Setting precursor, cursor and tail correctly is tricky.


assert wellFormed() : "invariant wrong at end of clone() for this";
assert result.wellFormed() : "invariant wrong for result of clone() for copy";
return result;
}

/**
* Gets a single instance of the comparator.
* @return a single instance of the comparator
*/
public static Comparator<Player> getInstance() { return instance; }

/**
* Gets a single instance of Nondiscrimination comparator.
* @return a single instance of Nondiscrimination comparator
*/
public static Comparator<Player> getInstance() { return instance; }

/**
* Instantiates a new Player.
* @param name the name of the player, must not be null
* @param score how many points this player has scored
* @param position the position of the player, where null means can play ANY position
*/
public Player(String name, int score, Position position) {
if (name == null) throw new NullPointerException("name cannot be null");
this.name = name;
this.position = position;
checkParameter("score",score);
this.score = score;
}

/** Gets the name.
* @return the name */
public String getName() {return name;}

/** Gets this player's score.
* @return the score */
public int getScore() {return score;}

/** Sets the score.
* @param the score */
public void setScore(int score) {this.score = score;}

/** Gets this player's position.
* @return the position */
public Position getPosition() {return position;}

/** Gets the previous player.
* @return the previous player */
public Player getPrevious() {return prev;}

/** Gets the next player.
* @return the next player */
public Player getNext() {return next;}

/**
* Add another player into this player's team by priority order.
* <ul>
* <li> If the other player has higher priority, place it somewhere before this player.
* <li> If the other player has equal priority, it should be placed immediately after this player.
* <li> If the other player has lower priority, place it somewhere after this player.
* </ul>
* It may be necessary to move multiple times forward or multiple times backward (but not both!)
* <p>
* Also, the code must use recursion to traverse the list - no loops are allowed!
* @param p the player to add to our list, must not be null
* @param priority comparator of players in the list, must not be null
*/
public void addInPriority(Player p, Comparator<Player> priority) {
// TODO: Implement this method.  No loops, only recursion
//
// NB: While Team happens to call this method only on the head of the list,
//	   we can't assume all classes that utilize Player will do so. That is why
//	   we must consider all scenarios, including those where this method is
//	   called on a player in the middle or end of the list.

if(priority.compare(p, this) < 0) {
if(next == null) {
p.prev = this;
next = p;
}else if(priority.compare(p, next) > 0) {
p.prev = this;
p.next = next;
next.prev = p;
next = p;
}else {
next.addInPriority(p, priority);
}
}else if(priority.compare(p, this) > 0) {
if(prev == null) {
p.next = this;
prev = p;
}else if(priority.compare(p, prev) < 0) {
p.next = this;
p.prev = prev;
prev.next = p;
prev = p;
}else {
prev.addInPriority(p, priority);
}
}else {//(priority.compare(p, this) == 0)
if(next == null) {
p.prev = this;
next = p;
}else {
p.prev = this;
p.next = next;
next.prev = p;
next = p;
}
}
}

/**
* Assuming all the players before this one are sorted correctly
* according to the priority and come before this one,
* ensure that the ones coming after are also sorted correctly.
* @param c comparator to use, must not be null
*/
public void sortByPriority(Comparator<Player> c) {
// TODO: Implement this method.  Use a loop here and then recursion
// when everything OK up to the next one.

if(next == null) return;

Player unsorted = next;
next.remove();
addInPriority(unsorted, c);
if(next == unsorted) next.sortByPriority(c);
else sortByPriority(c);

}

/**
* Remove this item from its list.
* This player will be completely disconnected from any other players.
*/
public void remove() {
// TODO: Implement this method.  No loops or recursion required.
if(prev != null && next != null) {
prev.next = next;
next.prev = prev;
}else if(prev != null && next == null) {
prev.next = null;
}else if(prev == null && next != null) {
next.prev = null;
}
next = null;
prev = null;
}

/**
* Instantiates a new Team with the given priority comparator.
* @param c the priority comparator this Team will use
* @param n the name of the team.
*/
public Team(Comparator<Player> c, String n) {
priority = c;
dummy = new Player("", Integer.MAX_VALUE, null);
teamName = n;

assert wellFormed() : "invariant fails at end of constructor";}

/**
* Adds a Player to this Team.
* It should be added according to the priority of the team.
* @param t the Player to add, must not be null and must not be in another team.
* @throws IllegalArgumentException if the player is already in a team or if the added player would come before the
* the dummy player (a player with an empty name, highest score possible and null position).
*/
public void add(Player t) {
assert wellFormed() : "invariant fails at beginning of add";
if(t.getNext() != null || t.getPrevious() != null) throw new IllegalArgumentException("Player already in team");

dummy.addInPriority(t, priority);

assert wellFormed() : "invariant fails at end of add";
}

/**
* Change the priority for this list of players,
* and then make sure the order reflects the new priority.
* @param p priority to use, must not be null.
*/
public void setPriority(Comparator<Player> p) {
assert wellFormed() : "invariant broken before set priority";
if (p == null) throw new NullPointerException("need a priority!");
priority = p;
refreshPriority();
assert wellFormed() : "invariant failed during set priority";
}

/**
* Some elements of the players may have changed the
* way the players are ordered.  This method
* reorders the list to fix things up.
* This will use insertion sort for efficiency.
* In particular if only a constant number of players
* are in the wrong position, this method will take linear time.
* If the priority ends up as "perverse" (something shows up
* before the dummy) we discard all team members.
* (This is not actually ideal for an ADT.)
*/
public void refreshPriority() {
assert wellFormed() : "invariant broken before refresh priority";
dummy.sortByPriority(priority);
if (dummy.getPrevious() != null) {
// Suddenly the priority shows up as perverse.
dummy.remove(); // actually removes everyone else.
}
assert wellFormed() : "invariant failed during refresh priority";
}

/**
* Compute the number of players.
* @return number of players
*/
public int size() {
assert wellFormed() : "invariant fails at beginning of size";

int count = 0;
for(Player source = dummy.getNext(); source != null; source = source.getNext()) {
count++;
}
return count;
}

/**
* Return the n'th player (0-based).
* @param index index of the element to return
* @return the player at the specified position in this list
* @throws IndexOutOfBoundsException if the index is out of range.
*/
public Player get(int index) {
assert wellFormed() : "invariant fails at beginning of get";

if(index < 0 || index >= size()) throw new IndexOutOfBoundsException("index is out of bounds");

int count = 0;
for(Player source = dummy.getNext(); source != null; source = source.getNext()) {
if(count == index) return source;
count++;
}
return null; // TODO
}

/**
* Returns team's total score
* @return the sum of all player's scores on this team
*/
public int totalScore() {
assert wellFormed() : "invariant fails at beginning of totalScore";
int score = 0;
//TODO implement totalScore (don't use the dummy player!)
for(Player source = dummy.getNext(); source != null; source = source.getNext()) {
score += source.getScore();
}
return score;
}

/**
* prints this team's players
*/
public void printPlayers() {
for(Player i = dummy.getNext(); i != null; i = i.getNext()) {
System.out.println(i);
}
}

/**
* Used to report an error found when checking the invariant.
* By providing a string, this will help debugging the class if the invariant should fail.
* @param error string to print to report the exact error found
* @return false always
*/
private boolean report(String error) {
reporter.accept(error);
return false;
}

/** Return the head node from the data structure since we do not have a head field. */
private Node<E> getHead() {
return tail.next.next;
}

/** Return the dummy node from the data structure since we do not have a dummy field. */
private Node<E> getDummy() {
return tail.next; // TODO
}

/** Return the cursor from the data structure since we do not have a cursor field. */
private Node<E> getCursor() {
return precursor.next; // TODO
}

/**
* Create an empty sequence.
* @param - none
* @postcondition
*   This sequence is empty
**/
public LinkedSequence( )
{
tail = precursor = new Node<E>();
size = 0;
assert wellFormed() : "invariant failed in constructor";
}

/**
* Determine the number of elements in this sequence.
* @param - none
* @return
*   the number of elements in this sequence
**/
public int size( )
{
assert wellFormed() : "invariant wrong at start of size()";
// TODO: Implemented by student.
// This method shouldn't modify any fields, hence no assertion at end
return size;
}

/**
* Set the current element at the front of this sequence.
* @param - none
* @postcondition
*   The front element of this sequence is now the current element (but
*   if this sequence has no elements at all, then there is no current
*   element).
**/
public void start( )
{
assert wellFormed() : "invariant wrong at start of start()";

precursor = getDummy();

assert wellFormed() : "invariant wrong at end of start()";
}

/**
* Accessor method to determine whether this sequence has a specified
* current element that can be retrieved with the
* getCurrent method.
* @param - none
* @return
*   true (there is a current element) or false (there is no current element at the moment)
**/
public boolean isCurrent( )
{
assert wellFormed() : "invariant wrong at start of getCurrent()";
// TODO: Implemented by student.
// This method shouldn't modify any fields, hence no assertion at end
return precursor != tail;
}

/**
* Accessor method to get the current element of this sequence.
* @param - none
* @precondition
*   isCurrent() returns true.
* @return
*   the current element of this sequence
* @exception IllegalStateException
*   Indicates that there is no current element, so
*   getCurrent may not be called.
**/
public E getCurrent( )
{
assert wellFormed() : "invariant wrong at start of getCurrent()";
if(!isCurrent()) throw new IllegalStateException("no current element");

return precursor.next.data;
}

/**
* Move forward, so that the current element is now the next element in
* this sequence.
* @param - none
* @precondition
*   isCurrent() returns true.
* @postcondition
*   If the current element was already the end element of this sequence
*   (with nothing after it), then there is no longer any current element.
*   Otherwise, the new element is the element immediately after the
*   original current element.
* @exception IllegalStateException
*   Indicates that there is no current element, so
*   advance may not be called.
**/
public void advance( )
{
assert wellFormed() : "invariant wrong at start of advance()";
if(!isCurrent()) throw new IllegalStateException("no current element");
precursor = precursor.next;
assert wellFormed() : "invariant wrong at end of advance()";
}

/**
* Remove the current element from this sequence.
* @param - none
* @precondition
*   isCurrent() returns true.
* @postcondition
*   The current element has been removed from this sequence, and the
*   following element (if there is one) is now the new current element.
*   If there was no following element, then there is now no current
*   element.
* @exception IllegalStateException
*   Indicates that there is no current element, so
*   removeCurrent may not be called.
**/
public void removeCurrent( )
{
assert wellFormed() : "invariant wrong at start of removeCurrent()";
if(!isCurrent()) throw new IllegalStateException("no element to remove");

if(size == 1) {
tail = tail.next;
tail.next = tail;
precursor = tail;
}else if(precursor.next == tail){
precursor.next = precursor.next.next;
tail = precursor;
}else {
precursor.next = precursor.next.next;
}

size--;
// TODO: Implemented by student.
// See textbook pp.176-78, 181-184
assert wellFormed() : "invariant wrong at end of removeCurrent()";
}

/**
* Add a new element to this sequence, before the current element (if any).
* @param element
*   the new element that is being added
* @postcondition
*   A new copy of the element has been added to this sequence. If there was
*   a current element, then the new element is placed before the current
*   element. If there was no current element, then the new element is placed
*   at the end of the sequence. In all cases, the new element becomes the
*   new current element of this sequence.
* @exception OutOfMemoryError
*   Indicates insufficient memory for increasing the sequence.
**/
public void insert(E element)
{

assert wellFormed() : "invariant failed at start of insert";
if(size == 0) {
tail = new Node<>(element, tail.next);
precursor = tail.next;
tail.next.next = tail;
}else if(precursor == tail) {
tail = new Node<>(element, precursor.next);
precursor.next = tail;
}else {
Node<E> node = new Node<>(element, precursor.next);
precursor.next = node;
}
size++;
assert wellFormed() : "invariant failed at end of insert";
}

/**
* Place the contents of another sequence (which may be the
* same one as this!) into this sequence before the current element (if any).
* @param addend
*   a sequence whose contents will be placed into this sequence
* @precondition
*   The parameter, addend, is not null.
* @postcondition
*   The elements from addend have been placed into
*   this sequence. The current element of this sequence (if any)
*   is unchanged.  The addend is unchanged.
* @exception NullPointerException
*   Indicates that addend is null.
* @exception OutOfMemoryError
*   Indicates insufficient memory to increase the size of this sequence.
**/
public void insertAll(LinkedSequence<E> addend) {

assert wellFormed() : "invariant failed at start of addAll";
if(addend == null) throw new NullPointerException("addend is null");
if(addend.size == 0) return;

LinkedSequence<E> clone = addend.clone();
if(size == 0) {
Node<E> cloneHead = clone.getHead();
clone.tail.next = precursor.next;
precursor.next = cloneHead;
precursor = clone.tail;
tail = clone.tail;
}else if(precursor == tail) {
Node<E> cloneHead = clone.getHead();
clone.tail.next = precursor.next;
precursor.next = cloneHead;
precursor = clone.tail;
tail = clone.tail;
}else {
Node<E> cloneHead = clone.getHead();
clone.tail.next = precursor.next;
precursor.next = cloneHead;
precursor = clone.tail;

}


size += clone.size;

assert wellFormed() : "invariant failed at end of addAll";
}

/**
* Generate a copy of this sequence.
* @param - none
* @return
*   The return value is a copy of this sequence. Subsequent changes to the
*   copy will not affect the original, nor vice versa.
*   Whatever was current in the original object is now current in the clone.
* @exception OutOfMemoryError
*   Indicates insufficient memory for creating the clone.
**/
@SuppressWarnings("unchecked")
public LinkedSequence<E> clone( )
{
assert wellFormed() : "invariant wrong at start of clone()";

LinkedSequence<E> result;

try
{
result = (LinkedSequence<E>) super.clone( );
}
catch (CloneNotSupportedException e)
{
// This exception should not occur. But if it does, it would probably
// indicate a programming error that made super.clone unavailable.
// The most common error would be forgetting the "Implements Cloneable"
// clause at the start of this class.
throw new RuntimeException
("This class does not implement Cloneable");
}

Node<E> cursor = new Node<>(tail.data, tail.next);
result.tail = cursor;
Node<E> source = tail.next;
while(source != tail) {
cursor.next = new Node<E>(source.data, source.next);
if(source == precursor) result.precursor = cursor.next;
cursor = cursor.next;
source = source.next;
}
cursor.next = result.tail;
result.tail.next.data = (E)result.tail.next;
if(source == precursor) result.precursor = cursor.next;


// TODO: Implemented by student.
// Now do the hard work of cloning the list.
// Similar to Homework #4, setting result.precursor requires an "if"
// It's possible to handle the dummy without a second if or an unsafe cast.
// but it's OK to have a second if and/or a cast to handle this.
assert wellFormed() : "invariant wrong at end of clone()";
assert result.wellFormed() : "invariant wrong for result of clone()";
return result;
}

/**
* Instantiates a new process.
*
* @param name the name of the process, must not be null
* @param totalIns the total instructions of the process
*/
public Process(String name, int totalIns) {
if (name == null) throw new NullPointerException("name must not be null");
this.name = name;
this.totalInstructions = totalIns;
}

/**
* Create an internal process to be used as a dummy node.
*/
private Process() {
name = null;
totalInstructions = 0;
}

/** Gets the name.
* @return the name */
public String getName(){return name;}

/** Gets the progress bar.
* Creates and initializes it if necessary.
* @return the progress bar */
public JProgressBar getBar(){
if (bar == null) createProgressBar();
return bar;
}

/** Gets the total amount of instructions in the process.
* @return the total instructions */
public int getTotal(){return totalInstructions;}

/**
* Gets the amount of finished instructions.
* @return the finished instructions */
public int getFinished(){return finishedInstructions;}

/**
* Checks if the process is completed.
* @return true, if is done */
public boolean isDone(){
return finishedInstructions == totalInstructions;}

/** Perform a single instruction of the process. */
public void performInstruction(){
if (!isDone())
finishedInstructions++;
}

/**
*  Returns a clone of this process that is identical in every way
*  except that it has null links.
*
* @return the process
* @see java.lang.Object#clone()
*/
@Override
public Process clone(){
Process copy = null;
try{
copy = (Process) super.clone();
copy.next = copy.prev = null;
copy.bar = null;
}
catch (CloneNotSupportedException e){
throw new RuntimeException("forgot to make Cloneable?");
}
return copy;
}

/**
*  Checks for equality of this process with the parameter process.
*  It will check everything except for the links.
*
* @param other the object against which to test for equality
* @return true, if successful
* @see java.lang.Object#equals(java.lang.Object)
*/
@Override
public boolean equals(Object other){
if (!(other instanceof Process) || other == null) return false;
Process p = (Process) other;

return p.totalInstructions == totalInstructions &&
p.finishedInstructions == finishedInstructions &&
p.name.equals(name);
}

/** Instantiates a new queue object.
*  It will only contain a dummy process with null name and 0 instructions,
*  linked circularly to itself. This dummy process should never be
*  passed outside of this class.
*  @postcondition queue is empty except for dummy process
*/
public Queue(){
dummy = new Process();
dummy.next = dummy;
dummy.prev = dummy;
version = 0;
manyItems = 0;
assert wellFormed() : "invariant failed in constructor";
}

/** Adds a new process to the end of the queue.
*
* @param p process to add to the end of this queue
* @throws NullPointerException if the process to add is null
* @throws IllegalArgumentException if the process is already in another queue
*
* @return true always
* @see java.util.Queue#offer(java.lang.Object)
*/
@Override
public boolean offer(Process p) {
assert wellFormed() : "invariant failed at start of offer";
if(p == null) throw new NullPointerException("Can't put null in list");
if(p.next != null || p.prev != null) throw new IllegalArgumentException("Item already in queue");

p.next = dummy;
p.prev = dummy.prev;
dummy.prev = p;
p.prev.next = p;
version++;
manyItems++;
assert wellFormed() : "invariant failed at end of offer";
return true;
}

/** Add all processes from parameter queue into the back of this queue.
*  The parameter queue should be empty after this method,
* except if the parameter is the same as this, in which case, nothing happens.
* @param pq the queue from which to take all processes, must not be null
*/
public void takeAll(Queue pq) {
assert wellFormed() : "invariant failed at start of takeAll";
if(pq == null) throw new NullPointerException("Queue is empty");
if(pq.manyItems == 0) return;
if(this == pq) return;

pq.dummy.prev.next = dummy;
pq.dummy.next.prev = dummy.prev;
dummy.prev.next = pq.dummy.next;
dummy.prev = pq.dummy.prev;
pq.dummy.prev = pq.dummy.next= pq.dummy;

manyItems += pq.manyItems;
pq.manyItems = 0;

version++;
pq.version++;

assert wellFormed() : "invariant failed at end of takeAll";
assert pq.wellFormed() : "parameter queue invariant failed at end of takeAll";
}

/** Returns the next process to be polled from this queue.
*
* @return the next process to be polled by this queue, or null if empty
* @see java.util.Queue#peek()
*/
@Override
public Process peek(){
assert wellFormed() : "invariant failed at start of peek";
if(manyItems == 0) return null;
return dummy.next;
}

/** Removes and returns the process at the start of this queue, null if empty.
*  This method should never return the dummy process!
*
* @returns the process at the start of this queue, or null if empty
* @see java.util.Queue#poll()
*/
@Override
public Process poll() {
assert wellFormed() : "invariant failed at start of poll";
if(manyItems == 0) return null;
Process result = dummy.next;
dummy.next = result.next;
result.next.prev = dummy;
result.next = null;
result.prev = null;
version++;
manyItems--;
assert wellFormed() : "invariant failed at end of poll";
return result;
}

/** Returns the number of non-dummy processes in this queue.
*
* @return the number of non-dummy processes
* @see java.util.AbstractCollection#size()
*/
@Override
public int size() {
assert wellFormed() : "invariant of result failed at start of size()";
return manyItems;
}

/** Returns a new copy of this queue. The copy should be unaffected
*  by subsequent changes made to this queue, and vice versa. The
*  processes added to the copy should be clones.
*
* @return a clone of this queue
* @see java.lang.Object#clone()
*/
@Override
public Queue clone(){
assert wellFormed() : "invariant failed at start of clone()";

Queue copy = new Queue();

try{ copy = (Queue) super.clone();}
catch(CloneNotSupportedException e){
// should not happen
}

Process source = dummy;
Process copier = source.clone();
copy.dummy = copier;
source = source.next;
while(source != dummy) {
copier.next = source.clone();
copier.next.prev = copier;
copier = copier.next;
source = source.next;
}
copier.next = copy.dummy;
copier.next.prev = copier;

assert wellFormed() : "invariant failed at end of clone()";
assert copy.wellFormed() : "invariant of result failed at end of clone()";
return copy;
}

public boolean hasNext() {
assert wellFormed() : "invariant failed at start of hasNext()";
if(version != myVersion) throw new ConcurrentModificationException("versions don't match");
return cursor.next != dummy;
}

/** Returns the next process in this queue. This method should
*  *not* call poll, or change the state of the queue in any way.
*
*  @throws ConcurrentModificationException if versions don't match
*  @throws NoSuchElementException if no element is next
*  @return the next process in the queue
*/
public Process next() {
assert wellFormed() : "invariant failed at start of next()";
if(version != myVersion) throw new ConcurrentModificationException("versions don't match");
if(!hasNext()) throw new NoSuchElementException("no element found");
cursor = cursor.next;
assert wellFormed() : "invariant failed at end of next()";
return cursor;
}

/** The main method.
* @param args the arguments */
public static void main(String[] args) {
if (args.length != 1) {
System.out.println("Usage: Main <lexicon file>");
System.exit(1);
}
new Driver(args[0]).run();
}

/** Instantiates a new driver, loading lexicon from file.
* @param name the name of the file */
public Driver(String name) {
lexicon = new Lexicon();
filename = name;
in = new Scanner(System.in);
}

/**
* Used to report an error found when checking the invariant.
* By providing a string, this will help debugging the class if the invariant should fail.
* @param error string to print to report the exact error found
* @return false always
*/
private boolean report(String error) {
reporter.accept(error);
return false;
}

/**
* Count all the nodes in this subtree,
* while checking that all the keys are all in the range (lo,hi),
* and that the keys are arranged in BST form.
* If a problem is found, -1 is returned and exactly one problem is reported.
* <p>
* @param n the root of the subtree to check
* @param lo if non-null then all strings in the subtree rooted
* 				at n must be [lexicographically] greater than this parameter
* @param hi if non-null then all strings in the subtree rooted
* 				at n must be [lexicographically] less than this parameter
* @return number of nodes in the subtree, or -1 is there is a problem.
*/
private int checkInRange(Node n, String lo, String hi)
{
if(n == null) return 0;
if(n.string == null) return reportNeg("n.string is null");
if(lo != null && n.string.compareTo(lo) <= 0) return reportNeg("not greater than lo");
if(hi != null && n.string.compareTo(hi) >= 0) return reportNeg("not less than hi");
int leftCount = checkInRange(n.left, lo, n.string);
if(leftCount == -1) return -1;
int rightCount = checkInRange(n.right, n.string, hi);
if(rightCount == -1) return -1;
return 1 + leftCount + rightCount;
/* Check that all strings in the subtree are in the parameter range,
* and none of them are null.
* Report any errors.  If there is an error return a negative number.
* (Write "return reportNeg(...);" when detecting a problem.)
* Otherwise return the number of nodes in the subtree.
* Note that the bounds in recursive calls may be different.
*/
}

/**
* Check the invariant.
* Returns false if any problem is found.
* @return whether invariant is currently true.
* If false is returned then exactly one problem has been reported.
*/
private boolean wellFormed() {
int sizeGuess = checkInRange(root, null, null);
if(sizeGuess == -1) return false;
if(sizeGuess != manyNodes) return report("manyNodes is wrong");
return true;
}

/** Gets the size of this lexicon.
* @return the count of strings in this lexicon
*/
public int size() {
assert wellFormed() : "invariant false at start of size()";
return manyNodes;
}

/**
* Gets the [lexicographically] least string in the lexicon.
* @return the least string or null if empty
*/
public String getMin() {
assert wellFormed() : "invariant false at start of getMin()";
if(root == null) return null;
Node source = root;
while(source.left != null) {
source = source.left;
}
return source.string;
}

/**
* Checks if the given string is in the lexicon.
* @param str the string to search for (maybe null)
* @return true if str is in the lexicon, false otherwise
*/
public boolean contains(String str) {
assert wellFormed() : "invariant false at start of contains()";
if(str == null) return false;
Node source = root;
while(source != null) {
if(source.string.compareTo(str) > 0) source = source.left;
else if(source.string.compareTo(str) < 0) source = source.right;
else return true;
}
return false;
}

/**
* Gets the next [lexicographically] greater string than the given string.
* @param str the string of which to find the next greatest
* @return the next string greater than str
* @throws NullPointerException if str is null
*/
public String getNext(String str) {
assert wellFormed() : "invariant false at start of getNext()";
if(str == null) throw new NullPointerException("str is null");
Node source = root;
Node before = null;
while(source != null) {
if(str.compareTo(source.string) < 0) {
before = source;
source = source.left;
}else if(str.compareTo(source.string) >= 0) {
source = source.right;
}
}
if(before == null) return null;
return before.string;
}

/**
* Accept into the consumer all strings in this lexicon.
* @param consumer the consumer to accept the strings
* @throws NullPointerException if consumer is null
*/
public void consumeAll(Consumer<String> consumer) {
// We don't assert the invariant, because we do nothing other than
// call another public method.
consumeAllWithPrefix(consumer,"");
}

/**
* Accept into the consumer all strings that start with the given prefix.
* @param consumer the consumer to accept the strings
* @param prefix the prefix to find all strings starting with
* @throws NullPointerException if consumer or prefix is null
*/
public void consumeAllWithPrefix(Consumer<String> consumer, String prefix) {
// TODO: Implement this to call the helper after preliminary checks (if any)
if(prefix == null) throw new NullPointerException("prefix is null");
if(consumer == null) throw new NullPointerException("consumer is null");
consumeAllHelper(consumer, prefix, root);
}

/**
* Add a new string to the lexicon. If it already exists, do nothing and return false.
* @param str the string to add (must not be null)
* @return true if str was added, false otherwise
* @throws NullPointerException if str is null
*/
public boolean add(String str) {
assert wellFormed() : "invariant false at start of add()";
if(str == null) throw new NullPointerException("str is null");
int manyNodesBefore = manyNodes;
root = addHelper(root, str);
assert wellFormed() : "invariant false at end of add()";
return manyNodesBefore != manyNodes;
}

/**
* Add all strings in the array into this lexicon from the range [lo,hi).
* The elements are added recursively from the middle, so that
* if the array was sorted, the tree will be balanced.
* All the tree mutations are done by add.
* Return number of strings actually added; some might not be added
* if they are duplicates.
* @param array source
* @param lo index lower bound
* @param hi index upper bound
* @return number of strings added
* @throws NullPointerException if array is null
*/
public int addAll(String[] array, int lo, int hi) {
assert wellFormed() : "invariant false at start of addAll()";
// TODO: Implement this method (be efficient!)
if(lo == hi) return 0;
int count = 0;
int mid = (hi - lo) / 2 + lo;
if(add(array[mid])) count++;
count += addAll(array, lo, mid);
count += addAll(array, mid + 1, hi);

// NB: As long as you never touch any fields directly (or call private methods)
// you shouldn't *need* to check the invariant. We will anyway.
assert wellFormed() : "invariant false at end of addAll()";
return count++;
}

/**
* Copy all the strings from lexicon (in sorted order) into the array starting
* at the given index.  Return the next index for (later) elements.
* This is a helper method for {@link #toArray(String[])}.
* @param array destination of copy
* @param root the subtree whose elements should be copied
* @param index the index to place the next element
* @return the next spot in the array to use after this subtree is done
*/
private int copyInto(String[] array, Node root, int index) {
if(root == null) return index;
index = copyInto(array, root.left, index);
array[index] = root.string;
index++;
index = copyInto(array, root.right, index);
return index;
}

/**
* Return an array of all the strings in this lexicon (in order).
* @param array to use unless null or too small
* @return array copied into
*/
public String[] toArray(String[] array) {
assert wellFormed() : "invariant false at the start of toArray()";
if(array == null || array.length < manyNodes) {
String[] array2 = new String[manyNodes];
copyInto(array2, root, 0);
return array2;
}else {
copyInto(array, root, 0);
return array;
}

}

/**
* Used to report an error found when checking the invariant.
* By providing a string, this will help debugging the class if the invariant should fail.
* @param error string to print to report the exact error found
* @return false always
*/
private boolean report(String error) {
reporter.accept(error);
return false;
}

/**
* Count all the nodes in this subtree,
* while checking that all the keys are all in the range (lo,hi),
* and that the keys are arranged in BST form.
* If a problem is found, -1 is returned and exactly one problem is reported.
* <p>
* @param n the root of the subtree to check
* @param lo if non-null then all strings in the subtree rooted
* 				at n must be [lexicographically] greater than this parameter
* @param hi if non-null then all strings in the subtree rooted
* 				at n must be [lexicographically] less than this parameter
* @return number of nodes in the subtree, or -1 is there is a problem.
*/
private int checkInRange(Node n, String lo, String hi)
{
//must account for checking an empty list or leaf's links
if (n == null) return 0;
if (n.string == null) return reportNeg("null word found");

//first check node r
if (lo != null && (n.string.equals(lo) || n.string.compareTo(lo) < 0))
return reportNeg("Detected node outside of low bound: "+n.string);
if (hi != null && (n.string.equals(hi) || n.string.compareTo(hi) > 0))
return reportNeg("Detected node outside of high bound: "+n.string);

//check subtrees
int leftSubtree =  checkInRange(n.left, lo, n.string);
if (leftSubtree < 0) return -1;

int rightSubtree = checkInRange(n.right, n.string, hi);
if (rightSubtree < 0) return -1;

//otherwise return 1 + nodes in subtrees
return 1 + leftSubtree + rightSubtree;
}

/**
* Check the invariant.
* Returns false if any problem is found.
* @return whether invariant is currently true.
* If false is returned then exactly one problem has been reported.
*/
private boolean wellFormed() {
int n = checkInRange(root, null, null);
if (n < 0) return false; // problem already reported
if (n != numNodes) return report("numNodes is " + numNodes + " but should be " + n);
return true;
}

/**
* Gets the [lexicographically] least string in the lexicon.
* @return the least string or null if empty
*/
public String getMin() {
assert wellFormed() : "invariant false at start of getMin()";
Iterator<String> it = iterator();
if(it.hasNext()) return it.next();
return null;
}

/**
* Gets the next [lexicographically] greater string than the given string.
* @param str the string of which to find the next greatest
* @return the next string greater than str, or null if no other
* @throws NullPointerException if str is null
*/
public String getNext(String str) {
assert wellFormed() : "invariant false at start of getNext()";
// TODO: Implement this method using the special iterator constructor.
// HINT: If you add "\0" to the string and look for it with the iterator,
// you are most of the way there.
if(str == null) throw new NullPointerException("str is null");
str.concat("\0");
Iterator<String> it = iterator(str);
String next = null;
if(it.hasNext()) next = it.next();
if(str.equals(next)) {
if(it.hasNext()) next = it.next();
else next = null;
}
return next;
}

/**
* Accept into the consumer all strings in this lexicon.
* @param consumer the consumer to accept the strings
* @throws NullPointerException if consumer is null
*/
public void consumeAll(Consumer<String> consumer) {
consumeAllWithPrefix(consumer,"");
}

/**
* Accept into the consumer all strings that start with the given prefix.
* @param consumer the consumer to accept the strings
* @param prefix the prefix to find all strings starting with
* @throws NullPointerException if consumer or prefix is null
*/
public void consumeAllWithPrefix(Consumer<String> consumer, String prefix) {
assert wellFormed() : "invariant false at start of consumeAllWithPrefix()";
if (consumer == null) throw new NullPointerException("Can't accept into null consumer");
if (prefix == null) throw new NullPointerException("Prefix can't be null");
// TODO: Implement this method with the special iterator, not with recursion.
Iterator<String> it = iterator(prefix);
boolean done = false;
while(it.hasNext() && !done) {
String next = it.next();
if(next.startsWith(prefix)) consumer.accept(next);
else done = true;
}
}

/**
* Add a new string to the lexicon. If it already exists, do nothing and return false.
* @param str the string to add (must not be null)
* @return true if str was added, false otherwise
* @throws NullPointerException if str is null
*/
@Override // implementation
public boolean add(String str) {
assert wellFormed() : "invariant false at start of add()";
boolean result = false;
if (str == null) throw new NullPointerException("Cannot add null.");
Node n = root;
Node lag = null;
while (n != null) {
if (n.string.equals(str)) break;
lag = n;
if (str.compareTo(n.string) > 0) n = n.right;
else n = n.left;
}
if (n == null) {
n = new Node(str);
if (lag == null)
root = n;
else if (str.compareTo(lag.string) > 0)
lag.right = n;
else
lag.left = n;
++numNodes;
result = true;
version++;
}
// XXX: Something is missing from this code that is needed for Homework #9
assert wellFormed() : "invariant false at end of add()";
return result;
}

/**
* Return an iterator that starts at the given element, or the next
* available element from the set.
* @param start starting element (or element before starting element,
* if the start isn't in the set), must not be null
* @return iterator starting "in the middle" (never null)
*/
public Iterator<String> iterator(String start) {
return new MyIterator(start);
}

/**
* Start the iterator at this element, or at the first element after it
* (if any).
* @param initial string to start at, must not be null
*/
public MyIterator(String initial) {
// TODO Set up an iterator starting with given (non-null) string.
// NB: Do not attempt to use {@link #getNext} or any other method
// of the main class to help.  All the work needs to be done here
// so that the pending stack is set up correctly.
if(initial == null) throw new NullPointerException("initial must not be null");
Node source = root;
while (source != null) {
if(initial.compareTo(source.string) < 0) {
pending.push(source);
source = source.left;
}else if(initial.compareTo(source.string) > 0) {
source = source.right;
}else {
pending.add(source);
break;
}
}
current = null;
colVersion = version;

assert wellFormed() : "Iterator messed up after special constructor";
}

/**
* Used to report an error found when checking the invariant.
* By providing a string, this will help debugging the class if the invariant should fail.
* @param error string to print to report the exact error found
* @return false always
*/
private static boolean report(String error) {
reporter.accept(error);
return false;
}

/**
* Count all the nodes in this subtree,
* while checking that all the keys are all in the range (lo,hi),
* and that the keys are arranged in BST form,
* and that the node are linked in-order.
* If a problem is found, -1 is returned and exactly one problem is reported.
* <p>
* @param n the root of the subtree to check
* @param lo if non-null then all strings in the subtree rooted
* 				at n must be [lexicographically] greater than this parameter
* @param hi if non-null then all strings in the subtree rooted
* 				at n must be [lexicographically] less than this parameter
* @param first the node that should be first in this tree, or if the tree
*        is empty, then this should be the next node
* @param next the node that should be linked next after this subtree.
* @return number of nodes in the subtree, or -1 is there is a problem.
*/
private int checkInRange(Node n, String lo, String hi, Node first, Node next)
{
if(n == null) {
if(first != next) return reportNeg("tree out of order");
return 0;
}
if (n.string == null) return reportNeg("null word found");
if (n.count <= 0) return reportNeg("Count is 0");
//first check node r
if (lo != null && (n.string.equals(lo) || n.string.compareTo(lo) < 0))
return reportNeg("Detected node outside of low bound: "+n.string);
if (hi != null && (n.string.equals(hi) || n.string.compareTo(hi) > 0))
return reportNeg("Detected node outside of high bound: "+n.string);

//if(first != null && first.string != null && lo != null && first.string.compareTo(lo) < 0) return reportNeg("lo and first are wrong");

//check subtrees
int leftSubtree = checkInRange(n.left, lo, n.string, first, n);
if (leftSubtree < 0) return -1;

int rightSubtree = checkInRange(n.right, n.string, hi, n.next, next);
if (rightSubtree < 0) return -1;

//otherwise return 1 + nodes in subtrees
return 1 + leftSubtree + rightSubtree;
}

/**
* Check the invariant.
* Returns false if any problem is found.
* @return whether invariant is currently true.
* If false is returned then exactly one problem has been reported.
*/
private boolean wellFormed() {
if(dummy == null) return report("dummy is null");
if(dummy.count != 0) return report("dummy.count isn't 0");
if(dummy.left != null) return report("dummy.left isn't null");
if(dummy.string != null) return report("dummy.string isn't null");
Node min = dummy.right;
while(min != null && min.left != null) min = min.left;
if(dummy.next != min)return report("dummy.next isn't the min");
int n = checkInRange(dummy.right, null, null, min, null);
if (n < 0) return false; // problem already reported
if (n != numEntries) return report("manyNodes is " + numEntries + " but should be " + n);
return true;
}

/**
* Look for the node for a particular key, creating it if requested
* if it doesn't exist.
* @param r subtree to look for the key, may be null
* @param key key to look for for, must not be null
* @param create whether to create a node with count 0 if not in tree
* @param before the node before the first node in this subtree, must not be null
* @return node with this key, or null if it is not present and create is false
*/
private Node getNode(Node r, String key, boolean create, Node before) {
if(r == null) {
if(!create) return null;
Node n = new Node(key);
n.count--;
n.next = before.next;
if(before.right == null) before.right = n;
else {
Node source = before.right;
while (source.left != null) source = source.left;
source.left = n;
}
before.next = n;

return n;
}
int c = key.compareTo(r.string);
if(c < 0) {
return getNode(r.left, key, create, before);
}
else if (c > 0) {
return getNode(r.right, key, create, r);
}else return r;

}

/**
* Find the node with the given key, creating it if necessary
* (but only if "create" is true).  If create is true, then
* the data structure invariant will be temporarily false
* due to the node with a zero count.  The caller must address
* the issue immediately.
* @param key word to look for, must not be null
* @param create whether to create a node with count=0 if not present.
* @return node, or null if not present (and create is false)
*/
private Node getNode(String key, boolean create) {
return getNode(dummy.right, key, create, dummy);
}

/**
* Add a new string to the multiset. If it already exists,
* increase the count for the string and return false.
* Otherwise, set the count to one and return true.
* @param str the string to add (must not be null)
* @return true if str was added, false otherwise
* @throws NullPointerException if str is null
*/
public boolean add(String str) {
assert wellFormed() : "invariant false at start of add";
if(str == null) throw new NullPointerException("String is null");
boolean result = false;
Node n = getNode(str, true);
if(n.count == 0) {
numEntries++;
version++;
result = true;
}
n.count++;
assert wellFormed() : "invariant false at end of add";
return result;
}

/**
* Remove one copy of a word from the multiset.
* If there are multiple copies, then we just adjust the count,
* and the map is unaffected (iterators don't go stale).
* @param str string to remove one of, may be null (but ignored if so)
* @return true if the word was in the multiset.
*/
public boolean removeOne(String str) {
assert wellFormed() : "invariant false at start of removeOne";
if(str == null) return false;
dummy.right = doRemove(dummy.right, str, dummy, true, null);
assert wellFormed() : "invariant false at end of removeOne";
return lastRemoved != null;
}

/** A method to compare two objects.
* This method is superseded by Objects.equals
* @param o1 one object, may be null
* @param o2 another object, may be null
* @return whether they are equal (both null, or usign equals).
*/
private static boolean eq(Object o1, Object o2) {
return (o1 == null ? o2 == null : o1.equals(o2));
}

/**
* Hash the key to a table index, following double hashing,
* returning the first index that
* (1) includes an entry with the key, or
* (2) has null, or
* (3) has a placeholder (if phOK is true *and* the key cannot be found).
* This code assumes that double hashing
* will find a valid index.  It may run forever otherwise.
* @param key string to look for, must not be null
* @param phOK whether we return a slot with a placeholder in preference to an empty slot
* @return first index meeting the requirements using double hashing.
*/
private int hash(String key, boolean phOK) {
if(key == null) throw new NullPointerException("String is null");
int phIndex = -1;

int hash1 = key.hashCode() % data.length;
if(hash1 < 0) hash1 += data.length;

int hash2 = key.hashCode() % (data.length - 2);
if(hash2 < 0) hash2 += data.length - 2;
hash2 += 1;

if(phOK && data[hash1] == PLACE_HOLDER && phIndex < 0) phIndex = hash1;
while(!(data[hash1] == null || (data[hash1].getKey() != null && data[hash1].getKey().equals(key)))) {
hash1 += hash2;
if(hash1 >= data.length) hash1 -= data.length;

if(phOK && data[hash1] == PLACE_HOLDER && phIndex < 0) phIndex = hash1;
}
if(data[hash1] != null && (data[hash1].getKey() != null && data[hash1].getKey().equals(key))) return hash1;
if(phOK && phIndex >= 0) return phIndex;
return hash1;
}

/**
* Used to report an error found when checking the invariant.
* By providing a string, this will help debugging the class if the invariant should fail.
* @param error string to print to report the exact error found
* @return false always
*/
private static boolean report(String error) {
reporter.accept(error);
return false;
}

/**
* Add a new string to the multiset. If it already exists,
* increase the count for the string and return false.
* Otherwise, set the count to one and return true.
* @param str the string to add (must not be null)
* @return true if str was added, false otherwise
* @throws NullPointerException if str is null
*/
public boolean add(String str) {
assert wellFormed() : "invariant false at start of add";
boolean result = false;

int i = hash(str, false);
if(isOpen(i)) {
if(data[i] == null) numUsed++;
result = true;
data[i] = new MyEntry(str);
numEntries++;
if(numUsed > data.length / 2) rehash();
version++;
}else {
data[i].count++;
}

assert wellFormed() : "invariant false at end of add";
return result;
}

/**
* Remove one copy of a word from the multiset.
* If there are multiple copies, then we just adjust the count,
* and the map is unaffected (iterators don't go stale).
* @param str string to remove one of, may be null (but ignored if so)
* @return true if the word was in the multiset.
*/
public boolean removeOne(String str) {
assert wellFormed() : "invariant false at start of removeOne";
boolean result = false;
if(str == null) return false;

int i = hash(str, false);
if(isOpen(i)) {
return false;
}else {
if(data[i].count == 1) remove(data[i].string);
else data[i].count--;
result = true;
}

assert wellFormed() : "invariant false at end of removeOne";
return result;
}

/**
* Return the shortest path between two vertices in the graph
* @param v1 starting vertex
* @param v2 ending vertex
* @return path from the first to the second as a list of vertices, or null
* is no path exists.
* @throws IllegalArgumentException if v1 or v2 is not in the graph
*/
@SuppressWarnings("unchecked")
public List<T> shortestPath(T v1, T v2) {

if(!(graph.containsVertex(v1) && graph.containsVertex(v2))) throw new IllegalArgumentException("Must be in graph");

ArrayDeque<ArrayList<T>> queue = new ArrayDeque<>();
HashSet<T> visited = new HashSet<>();
ArrayList<T> list = new ArrayList<>();

list.add(v1);
queue.push(list);
while(!queue.isEmpty()) {
list = queue.poll();
T current = list.get(list.size() - 1);
if(!visited.contains(current)) {
visited.add(current);
if(current.equals(v2)) {
return list;
}else {
Set<T> connected = graph.getConnected(current);
for(T vert : connected) {
    list.add(vert);
    queue.addLast((ArrayList<T>) list.clone());
    list.remove(list.size() - 1);
}
}
}
}

return null; // no path found
}

/**
* Read in a graph from the given reader.
* Each line (once trimmed of whitespace) names a vertex (a string),
* but before we trim, we check to see if the line begins with whitespace,
* in which case this vertex is the second vertex of an edge that
* begins with the last vertex that was on a line not starting with whitespace.
* <p> For example, the following text:
* <pre>
* A
* B
*   A
*   C
* </pre>
* is a graph with three vertices (A, B and C) and two
* edges, A-B and B-C.
* @param r
* @return graph represented by text of reader.
* @throws IOException if error reading or if the first line is indented.
*/
public static Graph<String> read(Reader r) throws IOException {
Graph<String> result = new HashGraph<>();
// TODO: Read in the graph from the reader.
// Our solution is 15 lines long, and it uses the following library classes:
// * BufferedReader

BufferedReader reader = new BufferedReader(r);
String before = null;
for(String s = reader.readLine(); s != null; s = reader.readLine()) {
if(s.startsWith(" ") || s.startsWith("\t")) {
if(before == null) throw new IOException("can't lead with white space");
s = s.strip();
if(!result.containsVertex(s)) result.addVertex(s);
if(!result.containsEdge(s, before)) result.addEdge(s, before);
}else {
s = s.strip();
if(!result.containsVertex(s)) result.addVertex(s);
before = s;
}
}

return result;
}

/**
* Return an empty stack.
* @return empty stack, never null
*/
@SuppressWarnings("unchecked")
public static <T> ImmutableStack<T> empty() {
return (ImmutableStack<T>) empty;
}

/**
* Return the top of the stack.
* @throws NoSuchELementException if the stack is empty
* @return top of the stack
*/
public T top() {
if (this == empty) throw new NoSuchElementException("stack is empty");
return top;
}

/**
* Return the stack that results from popping off the top element.
* @throws NoSuchElementException if the stack is empty
* @return stack after popping element
*/
public ImmutableStack<T> pop() {
if (this == empty) throw new NoSuchElementException("empty stack");
return shorter;
}

/**
* Return the stack that results from pushing another element on top.
* @param val element to push
* @return new stack resulting from pushing element
*/
public ImmutableStack<T> push(T val) {
return new ImmutableStack<>(val,this);
}

/**
* Create a CLL from the elements in the given collection in the same order.
* @param dummy dummy node to use, if null, a new dummy will be created
* @param coll collection to use, must not be null, but may be empty
* @return CLL of elements in same order
*/
private Node<E> toCLL(Node<E> dummy, Collection<? extends E> coll) {
if (dummy == null) dummy = new Node<E>(null,null);
dummy.next = dummy;
Node<E> t = dummy;
for (E e : coll) {
t = t.next = new Node<E>(e,dummy);
}
return t;
}

/**
* Convert a CLL to a string.
* A problem is signified by a string without a proper ending paren.
* Use this for debugging.
* @param tail CLL
* @return string picture of a CLL
*/
private static <E> String CLLtoString(Node<E> tail) {
if (tail == null) return "<NULL>";
Node<E> dummy = tail.next;
if (dummy == tail) return "()";
if (dummy == null) return "<NO DUMMY>";
if (dummy.data != null) return "<DUMMY " + dummy.data + ">";
Node<E> head = dummy.next;
StringBuilder sb = new StringBuilder();
Node<E> fast = head.next;
while (head != dummy) {
if (head == null) return sb.toString(); // no closing paren
if (head == fast) {
System.out.println("...");
return sb.toString();
}
if (sb.length() == 0) sb.append("(");
else sb.append(",");
sb.append(head.data);
head = head.next;
if (fast != dummy && fast != null) fast = fast.next;
if (fast != dummy && fast != null) fast = fast.next;
}
sb.append(")"); // clean close
return sb.toString();
}

/**
* Merge two sorted CLLs, or rather, merge the elements
* of the second list into the first list.
* This method should not create any new nodes!
* The lists may have duplicates (according to the comparator)
* but will be in non-decreasing order w.r.t. the comparator.
* The result should include the dummy from the first CLL
* and the second CLL should be left empty (dummy points to itself).
* @note This method does not efficiently handle when the second list
* contains a single element that belongs at the end of the first list.
* In other words, this method does not do the work of insertion sort.
* @param t1 tail of first CLL
* @param t2 tail of second CLL
* @return tail of merged list (first CLL with nodes of second CLL merged in)
*/
private Node<E> merge(Node<E> t1, Node<E> t2) {
if(t2.next == t2) return t1;
if(t1.next == t1) {
Node<E> dummy = t2.next;
t1.next = t2.next.next;
t2.next = t1;
t1 = t2;
t2 = dummy;
t2.next = t2;
return t1;
}
Node<E> n1 = t1.next.next;
Node<E> n2 = t2.next.next;

Node<E> cur;
if(comparator.compare(n1.data, n2.data) < 0) {
cur = n1;
n1 = n1.next;
}else {
cur = n2;
n2 = n2.next;
}
Node<E> first = cur;
Node<E> dum1 = t1.next;
Node<E> dum2 = t2.next;

while(n1.data != null && n2.data != null) {
if(comparator.compare(n1.data, n2.data) < 0) {
cur.next = n1;
cur = cur.next;
n1 = n1.next;
}
else {
cur.next = n2;
cur = cur.next;
n2 = n2.next;
}
}
while(n1.data != null) {
cur.next = n1;
cur = cur.next;
n1 = n1.next;
}
while(n2.data != null) {
cur.next = n2;
cur = cur.next;
n2 = n2.next;
}
cur.next = dum1;
t1 = cur;
t1.next.next = first;
t2 = dum2;
t2.next = t2;

return t1;
}

/**
* Partition a CLL w.r.t. the first element in the list.
* The list elements are rearranged so that those which
* are less that the pivot are placed before it, and those
* that are greater are placed after them.  Equal elements
* will be placed in the "after" list right after the pivot.
* The elements may be rearranged arbitrarily otherwise.
* @param tail the last element of the CLL.
* There must be at least one element in this list
* @return new tail
*/
private Node<E> partition(Node<E> tail) {
Node<E> cur = tail.next.next;
Node<E> p = cur;
E pivot = cur.data;
Node<E> dum = tail.next;
Node<E> prev = tail.next;

while(cur.data != null) {
if(comparator.compare(cur.data, pivot) < 0) {
Node<E> next = cur.next;
prev.next = cur.next;
cur.next = dum.next;
dum.next = cur;
cur = next;
}else if(comparator.compare(cur.data, pivot) == 0 && cur != p) {
Node<E> next = cur.next;
prev.next = cur.next;
cur.next = p.next;
p.next = cur;
if(prev.next != next) prev = prev.next;
cur = next;
}else {
prev = cur;
cur = cur.next;
}
}

tail = prev;

return tail;
}

/**
* Destructively sort a CLL using quicksort, and return it.
* The pivot chose should always be the first element.
* @param l CLL identified by its tail
*/
private Node<E> quicksort(Node<E> tail) {
if(tail.next.next == tail) return tail;

Node<E> pivot = tail.next.next;
Node<E> dum = tail.next;
tail = partition(tail);

Node<E> tail2 = tail.next;
while(tail2.next != pivot) tail2 = tail2.next;
tail2.next = dum;
tail2 = quicksort(tail2);
Node<E> beforeHead = tail2.next.next;
tail2.next = beforeHead;

if(tail == pivot) tail = dum;
tail.next = dum;
dum.next = pivot.next;
tail = quicksort(tail);
Node<E> afterHead = tail.next.next;

tail2.next = pivot;
pivot.next = afterHead;
if(tail.data == null) tail = pivot;
tail.next = dum;
if(beforeHead.data != null) dum.next = beforeHead;

return tail;
}

/**
* Create a sorted collection using the given comparator.
* @param comp comparator to use, must not be null
*/
public SortedCollection(Comparator<E> comp) {
if (comp == null) throw new IllegalArgumentException("comparator cannot be null");
// TODO set up data structure for an empty list.
comparator = comp;
tail = new Node<>(null, null);
tail.next = tail;
size = 0;
version = 0;
assert wellFormed() : "invariant failed at end of constructor";
}

/**
* Create a sorted collection with the natural comparator,
* and with all the elements from the given collection
* @param from collection to get elements from, must not be null
*/
public SortedCollection(Collection<? extends E> from) {
this();
addAll(from);
assert wellFormed() : "invariant failed at end of constructor";
}

/**
* Create an array robot with the given capacity
* If the capacity is zero, the robot cannot have any parts
* @param cap capacity to use, cannot be negative
*/
public ArrayRobot(int cap)
{
functions = new String[cap];
parts = new Part[cap];
}

/**
* Add a part to the robot.
* @param function the type of part this is (arm, leg, etc), must not be null
* @param part the part to add, must not be null.
* @return whether the part was added.
* @exception NullPointerException if the function or part is null
*/
@Override//required
public boolean addPart(String function, Part part)
{
if(function == null || part == null) throw new NullPointerException();
for (int i=0; i < functions.length; ++i)//For the empty space,
{
if(functions[i] == null) {//put it here! Checks if the space is empty
functions[i] = function;//puts function into the space
parts[i] = part;//puts part into the space
return true;//confirms that it was added
}
}
return false;
}

/**
* Remove a part from the robot if there is one with this function.
* @param function the type of part to remove, null means any part
* @return part that was removed
*/
@Override // required
public Part removePart(String function)
{
for(int i = 0; i < functions.length; ++i)
{
if(parts[i] == null) continue;
//The continue statement allows us to look over nulls and look for
//next available part, moving beyond just index zero if needed.
if(function == null || function.equals(functions[i]))//remove this one
{
Part p = parts[i];
functions[i] = null;
parts[i] = null;
return p;
}
}
return null;
}

/**
* Return the part with the given function.
* @param function the type of part to look for, null means any part
* @param index zero-based index of part to return of the given type, must not be negative
* @return indicated part, or null if no such part (index is at least the number of this kind of kind)
*/
@Override//required
public Part getPart(String function, int index)
{
if(index < 0) throw new IllegalArgumentException("index cannot be negative: " + index);

for(int i=0; i < functions.length; ++i)
{
if(parts[i] == null)continue;
else if(function == null)
{
if(index-- == 0)return parts[i];
}
else if(function.equals(functions[i]))
{
if(index-- == 0)return parts[i];
}
}
return null;
}

/**
* Add a part to the robot.
* @param function the type of part this is (arm, leg, etc), must not be null
* @param part the part to add, must not be null.
* @return whether the part was added.
* @exception NullPointerException if the function or part is null
*/
@Override // required
public boolean addPart(String function, Part part)
{
if(function == null || part == null) throw new NullPointerException("part cannot be null");//exception thrown if there is no part
if(function.equals(ARM))//if function is and arm
{
if(arm1 == null)//if arm1 is empty...
{
arm1= part;//put the contents of part into arm1
return true;//confirm that it worked
}
else if(arm2 == null)//if arm2 is empty....
{
arm2 = part;//put the contents of part into arm2
return true;//confirm that it worked
}
}

else if(function.equals(LEG))//if fucntion is leg
{
if(leg1 == null)//if leg1 is empty...
{
leg1 = part;//put contents of part into leg1
return true;//confirm that it worked.
}
else if(leg2 == null)//if leg2 is empty...
{
leg2 = part;//put contents of part into leg2
return true;//confirm that it worked
}

}
else if(otherFunction == null)//if it's anything else like a head
{
otherFunction = function;//put the contents of function into otherFunction
otherPart = part;//put the contents of part into otherPart
return true;//confirm it works
}
return false;//Nothing happens
}

/**
* Remove a part from the robot if there is one with this function.
* @param function the type of part to remove, null means any part
* @return part that was removed
*/
@Override // required
public Part removePart(String function) {
Part result = null;
if(function == null)
{
if(arm1 != null)
{
result = arm1;
arm1 = null;
}
else if(arm2 != null)
{
result = arm2;
arm2 = null;
}
else if(leg1 != null)
{
result = leg1;
leg1 = null;
}
else if(leg2 != null)
{
result = leg2;
leg2 = null;
}
else if(otherPart != null)
{
result = otherPart;
otherPart = null;
}
}

else if(function.equals(ARM))
{
if(arm1 != null)
{
result = arm1;
arm1 = null;
}
else if(arm2 != null)
{
result = arm2;
arm2 = null;
}
}
else if(function.equals(LEG))
{
if(leg1 != null)
{
result = leg1;
leg1 = null;
}
else if(leg2 != null)
{
result = leg2;
leg2 = null;
}
}
else
{
if(otherPart != null)
{
result = otherPart;
otherPart = null;
}
}
return result;
}

/**
* Return the part with the given function.
* @param function the type of part to look for, null means any part
* @param index zero-based index of part to return of the given type, must not be negative
* @return indicated part, or null if no such part (index is at least the number of this kind of kind)
*/
@Override // required
public Part getPart(String function, int index) {
if(index < 0)throw new IllegalArgumentException("Index cannot be negative.");

Part result = null;

if(function == null  || function.equals(ARM))
{
if(arm1 != null)
{
if(index-- == 0)result = arm1;
}
if(arm2 != null)
{
if(index-- == 0)result = arm2;
}
}
if(function == null||function.equals(LEG))
{
if(leg1 != null)
{
if(index-- == 0)result = leg1;
}

if(leg2 != null)
{
if(index-- == 0)result = leg2;
}
}
if(function == null || function.equals("head"))
{
if(index-- == 0) result = otherPart;
}

return result;
}

/**
* Create a part with the given serial number
* @param serial serial number, must not be null
*/
public Part(String serial)
{
//initialize the part after checking for errors.
if(serial == null) throw new NullPointerException("null is not a serial number");
this.serial = serial;
}

/**
* Create a part with a random serial number.
*/
public Part()
{
// call the other constructor with "this(...)"
// filling in the "..." with a random string which
// can indeed be a series of digits.
// Our solution uses "new Random().nextInt()" as part of this.
this("RSN" + new Random().nextInt());
}

/**
* Indicates whether some other object is "equal to" this one.
* @param x the reference object with which to compare.
* @return true if this object is the same as the obj argument; false otherwise.
*/
@Override//implementation
public boolean equals(Object x)
{
if(!(x instanceof Part)) return false;
Part p = (Part)x;
return serial.equals(p.serial);
}

/**
* @return a hash code value for the object.
*/
@Override//implementation
public int hashCode()
{
return serial.hashCode();
}

/**
* @return a string representation of the object.
*/
@Override // implementation
public String toString()
{
return "Part(" + serial + ")";
}

/**
* @return the serial number of this part
*/
public String getSerial()
{
return serial;
}

/**
* Return once the data structure has been updated so that
* the capacity of the arrays is at least the parameter.
* If we create new arrays, they will be at least twice as long as the existing arrays.
* This code assumes the arrays are the same length, and preserves this property.
* @param cap capacity desired
*/
private void ensureCapacity(int cap)
{
// Follow activity but update to handle two arrays at once (same length)
if(cap <= functions.length && cap <= parts.length) return;
int newSize = functions.length*2;
if(newSize < cap)cap = newSize;
String[] newFunctions = new String[newSize];
Part[] newParts = new Part[newSize];
for(int i=0; i < size; ++i)
{
newFunctions[i] = functions[i];
newParts[i] = parts[i];
}
functions = newFunctions;
parts = newParts;
}

/**
* Create an empty part sequence.
*/
public DynamicArrayPartSeq() {
this(INITIAL_CAPACITY); // call specifying constructor to do the work
// no assertion required because other constructor asserts it
}

/**
* Create a dynamic array part sequence with the given capacity
* (how many parts that can be added without requiring allocation of a new array).
* @param cap number of elements to prepare for, cannot be negative
*/
public DynamicArrayPartSeq(int cap) {
// TODO
functions = new String[cap];
parts = new Part[cap];

assert wellFormed() : "invariant broken by constructor";
}

/**
* Return the number of elements in the sequence.
* @return number of elements in sequence
*/
public int size() {
assert wellFormed() : "invariant broken in size";
return size;
}

/**
* Start running through all parts.
*/
public void start() {
// not asserting invariant before this will be done by the other start
start(null);
}

/**
* Start running through all parts with the given function.
* @param function kind of parts to access, may be null (any part)
*/
public void start(String function)
{
// TODO: don't forget to assert the invariant twice: before and after
assert wellFormed():"invariant broken in start.";
if(function == null)
{
this.function =null;
currentIndex=0;
return;
}
this.function = function;
currentIndex = -1;
moveForStart();
assert wellFormed():"invariant broken in start";
}

/**
* Return whether there is a current element.
* @return whether there is a current element
*/
public boolean isCurrent()
{
assert wellFormed():"invariant broken in isCurrent";
return currentIndex < size;
}

/**
* Return the current element.
* This method can only be called if there is a current element.
* @return the part which is current
* @throws IllegalStateException if there is no current element
*/
public Part getCurrent() {
assert wellFormed():"invariant broken in getCurrent.";
if(parts[currentIndex] == null)throw new IllegalStateException("There is no current element in getCurrent.");
return parts[currentIndex];
}

/**
* Move the cursor to the next part with the current function.
* If there is no such part, then after this call, there is no current element.
* @throws IllegalStateException
*/
public void advance() {
assert wellFormed() : "invariant broken in advance";
// TODO (our solution uses the helper method)
if(currentIndex > size-1)throw new IllegalStateException("Current index is greater than the size.");
if(function==null)
{
currentIndex++;
assert wellFormed():"invariant broken by advance.";
return;
}
for(int i =currentIndex+1;i < size;i++) {
if(function.equals(functions[i])){
currentIndex=i;
assert wellFormed():"invariant broken by advance.";
return;
}
}
currentIndex=size;
assert wellFormed() : "invariant broken by advance";
}

/**
* Remove the current element.  Then the next part (of the function)
* is made current, or there is no current if there are not more parts
* (of the function).
* @throws IllegalStateException if there is no current element
*/
public void removeCurrent() {
// TODO: lots to do
assert wellFormed(): "invariant broken in removeCurrent";
if(functions[currentIndex] == null || parts[currentIndex]== null)
{
throw new IllegalStateException("There is no current element.");
}

functions[currentIndex]=null;
parts[currentIndex]=null;
size--;

if(currentIndex+1 < functions.length && functions[currentIndex+1]!=null) shiftLeft(currentIndex);

if(size==0)
{
assert wellFormed():"invariant broken by removeCurrent";
return;
}
else if(function != null)
{
while(currentIndex<size)
{
if(function.equals(functions[currentIndex]))
{
break;
}
currentIndex++;
}
}

assert wellFormed():"invariant broken by removeCurrent";
}

/**
* Add a part before the current element.  If there is no current element,
* then add at the beginning.  There must have been a function
* defined (See [@link #start(String)}).
* @throws IllegalStateException if no function defined, or if the function was null
* @param p part to add at this spot, must not be null.
*/
public void addBefore(Part p) {
assert wellFormed() : "invariant broken in addBefore";
// TODO
if(p==null)throw new NullPointerException("Null data cannot be added to the array.");
if(function == null)throw new IllegalStateException("function cannot be null or undefined in addBefore.");
ensureCapacity(size*2);
if(functions[currentIndex]==null)
{
shiftRight(0);
functions[0] = function;
parts[0] = p;
currentIndex=0;
}
else
{
shiftRight(currentIndex);
functions[currentIndex] = function;
parts[currentIndex] = p;
}
size++;
ensureCapacity(size*2);
assert wellFormed() : "invariant broken by addBefore";
}

/**
* Add a part after the current element.  If there is no current element,
* then add at the end.  There must have been a function
* defined (See [@link #start(String)}).
* @throws IllegalStateException if no function defined, or if the function was null
* @param p part to add at this spot, must not be null.
*/
public void addAfter(Part p) {
// TODO: (remember the invariant!)
assert wellFormed():"invariant broken in addAfter";
if(p==null) throw new NullPointerException("Cannot add null data to the array.");
ensureCapacity(size*2);
if(function == null)throw new IllegalStateException("function cannot be null or undefined in addBefore.");
if(size==0)
{
doAdd(0,p);
assert wellFormed():"invariant broken by addAfter";
return;
} else if(currentIndex==size) {
doAdd(size, p);
assert wellFormed():"invariant broken by addAfter";
return;
}

shiftRight(currentIndex);
doAdd(currentIndex+1,p);
currentIndex++;
assert wellFormed():"invariant broken by addAfter";
}

/**
* Return the function of this part.
* @return string of this part, null if this part not in a robot
*/
public String getFunction() {
return function;
}

/**
* Return the next part in this robot.
* This is valid only if the part is in a robot.
* @return the next part, possibly null
* @exception IllegalStateException if this part is not a part of a robot
*/
public FunctionalPart getNext() {
if (function == null) throw new IllegalStateException("not part of a robot");
return next;
}

/**
* Create a wired robot without parts
* and no order.
*/
public WiredRobot()
{
this(null);
}

/**
* Create a wired robot without parts
* with the given order
* @param comp order to use, if null, then unordered
*/
public WiredRobot(Comparator<FunctionalPart> comp) {
if(comp == null)
{
comp = (p1,p2) -> 0;
}
this.comparator = comp;
dummy = new FunctionalPart();
assert wellFormed() : "Invariant not established by constructor";
}

/**
* Return the function of this part.
* @return string of this part, null if this part not in a robot
*/
public String getFunction() {
return function;
}

/**
* Return the next part in this robot.
* This is valid only if the part is in a robot.
* @return the next part, possibly null
* @exception IllegalStateException if this part is not a part of a robot
*/
public FunctionalPart getNext() {
throw new UnsupportedOperationException("not implemented");
}

/**
* Compare two parts according to our purposes.
* We use the supplied comparator except when it
* says it doesn't care, in which case, we use the (unique) id to
* distinguish two parts, older first.
* @param p1 first part, must not be null
* @param p2 second part, must not be null
* @return comparison, only 0 if p1 and p2 are the same
*/
private int compare(FunctionalPart p1, FunctionalPart p2) //Received assistance from Alex K in tutoring center
{
if(comparator == null || comparator.compare(p1, p2) == 0)
{
if(p1.getId() < p2.getId())
{
return -1;
}
else if(p1.getId() == p2.getId())
{
return 0;
}
else if(p1.getId() > p2.getId())
{
return 1;
}
}
return comparator.compare(p1, p2);
}

/**
* Check a tree of parts within bounds.
* The subtree must be properly ordered, and every part
* must have a non-null function assigned.
* @param r root of subtree to check, may be null
* @param lo lower bound (exclusive) of all parts in subtree.
*   If null, then no lower bound
* @param hi upper bound (exclusive) of all parts in subtree.
*   If null, then no upper bound
* @return whether the subtree checks out OK.
* If false is returned, then exactly one report has been generated.
*/
private boolean checkInRange(FunctionalPart r, FunctionalPart lo, FunctionalPart hi) //Received assistance from Alex Dueppen in tutoring center
{
/***************************
* We need a base case
* Then do some work
* We need a recursive call
* Only work with r
***************************/
//if r is null there is nothing to check
if(r == null)return true;
if(!checkInRange(r.left,lo,r)) return false;
if(!checkInRange(r.right,r,hi))return false;

//1.Checking if function is null
if(r.function == null)return report("roots function cannot be null if the part is not null.");

//2.
//Checking if lo < r < hi
if(lo != null && compare(r,lo) <= 0)return report("lo is greater than root");
if(hi != null && compare(r,hi) >= 0)return report("hi is less than the root");

return true;
}

/**
* Create a wired robot without parts
* and no order.
*/
public WiredRobot() {
this(null);
}

/**
* Create a wired robot without parts
* with the given order
* @param comp order to use, if null, then unordered
*/
public WiredRobot(Comparator<FunctionalPart> comp) {

if(comp == null)
{
comp = (p1,p2) -> 0;
}
comparator = comp;
root = null;
assert wellFormed() : "Invariant not established by constructor";
}

/**
* Return the 0-based index part from the subtree given that
* matches the given function.  The mutable index should be decremented
* for every part we find that matches, so that if we find a match
* when it is zero we return that one.  Once we find the result, we stop
* looking (and stop decrementing).  If there is no such functional part,
* this method returns null.
* @param r subtree to examine, may be null
* @param function kind of part to look for, null means any part
* @param mutableIndex index to look for (0-based); decremented whenever a matching
*   part is encountered in in-order traversal until the desired index.
* @return 0-based matching part, may be null
*/
private static FunctionalPart getHelper(FunctionalPart r, String function, Cell<Integer> mutableIndex)
{
if(r == null)
{
return null;
}

//r.left first, r second, r.right third
//First go into the left subtree to find the function.  Delegate, don't micromanage
FunctionalPart tempLeft = getHelper(r.left, function, mutableIndex);
if(tempLeft !=null) return tempLeft;

if(function == null || r.function.equals(function))
{
if(mutableIndex.get() == 0)return r;
mutableIndex.set(mutableIndex.get()-1);
}

FunctionalPart tempRight = getHelper(r.right, function,mutableIndex);
if(tempRight != null)return tempRight;

return null;
// Use recursion.  Do not micro-manage!
// Never check a child for null or look at its function.
}

/**
* Helper method for addPart.
* @param r
* @param add
* @return r
*/
private FunctionalPart insert(FunctionalPart r, FunctionalPart add)
{

if(r==null)
{
r=add;
}
else if(compare(add,r) < 0)
{
r.left = insert(r.left,add);
}
else//if(compare(add,r) > 0)
{
r.right = insert(r.right,add);
}
return r;
}

/**
* Return the first part in this robot.
* @return the first part, null if this robot is empty
*/
public FunctionalPart getFirst()
{
assert wellFormed():"invariant broken in getFirst";
if(root == null)
{
return null;
}
FunctionalPart getter = root;
while(getter.left != null)
{
getter = getter.left;
}
assert wellFormed():"invariant broken in getFirst";
return getHelper(getter,null, new Cell<>(0));
}

/**
* Change the comparator used to order the robot parts.
* The parts will be reorganized as necessary to accommodate the new order,
* but two parts will be reordered only if necessary.
* (The sorting is "stable".)
* @param comp comparator to use, if null, then henceforth the parts
* can be in any order.
*/
public void setComparator(Comparator<FunctionalPart> comp) {
assert wellFormed() : "invariant broken in setComparator";
//: Complete this!
// Hint: After handling special easy case,
//   reinsert all parts back into an emptied tree
//      in pre-order over the tree.
//      This requires a new helper method.

comparator = comp;
if(root == null)return;
FunctionalPart savedRoot = root;
root = null;
compHelper(savedRoot);

assert wellFormed() : "invariant broken by setComparator";
}

/** Change the stored value to the given value.
* @param newValue new value for cell, may be null
*/
public void set(T newValue) {
value = newValue;
}

/**
* Return the function of this part.
* @return string of this part, null if this part not in a robot
*/
public String getFunction() {
return function;
}

/**
* Return the next part in this robot.
* This is valid only if the part is in a robot.
* @return the next part, possibly null
* @exception IllegalStateException if this part is not a part of a robot
*/
public FunctionalPart getNext() {

if(this.getFunction() == null)throw new IllegalStateException("Part is not in the robot");
FunctionalPart cur = this;

if(cur.right != null)
{
if(cur.right.left != null)
{
cur = cur.right.left;
while(cur.left !=null)
{
cur = cur.left;
}

return cur;
}
cur = cur.right;
return cur;
}

else{
if(cur.parent == null)return null;
if(cur.parent.left == cur)
{
cur = cur.parent;
}
else
{
if(cur.parent == null)return null;
while(cur.parent.left != cur)
{
cur = cur.parent;
if(cur.parent == null)return null;
}
cur = cur.parent;
}

return cur;
}
}

/**
* Compare two parts according to our purposes.
* We use the supplied comparator except when it
* says it doesn't care, in which case, we use the (unique) id to
* distinguish two parts, older first.
* @param p1 first part, must not be null
* @param p2 second part, must not be null
* @return comparison, only 0 if p1 and p2 are the same
*/
private int compare(FunctionalPart p1, FunctionalPart p2) {
if (comparator != null) {
int c= comparator.compare(p1, p2);
if (c != 0) return c;
}
return p1.getId() - p2.getId();
}

/**
* Check a tree of parts within bounds.
* The subtree must be properly ordered, and every part
* must have a non-null function assigned.
* @param r root of subtree to check, may be null
* @param lo lower bound (exclusive) of all parts in subtree.
*   If null, then no lower bound
* @param hi upper bound (exclusive) of all parts in subtree.
*   If null, then no upper bound
* @param p the parent part
* @return whether the subtree checks out OK.
* If false is returned, then exactly one report has been generated.
*/
private boolean checkInRange(FunctionalPart r, FunctionalPart lo, FunctionalPart hi, FunctionalPart p) {
if (r == null) return true;
if (r.function == null) return report("Has null function: " + r);
if (lo != null && compare(lo, r) >= 0) return report("Out of lo bound: " + r + " <= " + lo);
if (hi != null && compare(r,hi) >= 0) return report("Out of hi bound: " + r + " >= " + hi);

//Checking if the roots parent is equal to the parent parameter
if(r.parent != p)return report("Out of root bound");

//r goes into the p param because when you move down the tree the root variable becomes the parent
return checkInRange(r.left, lo, r,r) && checkInRange(r.right, r, hi,r);
}

/**
* Create a wired robot without parts
* and no order.
*/
public WiredRobot() {
this(null);
}

/**
* Create a wired robot without parts
* with the given order
* @param comp order to use, if null, then unordered
*/
public WiredRobot(Comparator<FunctionalPart> comp) {
comparator = comp;
assert wellFormed() : "Invariant not established by constructor";
}

/**
* Return the first part in this robot.
* @return the first part, null if this robot is empty
*/
public FunctionalPart getFirst() {
assert wellFormed() : "invariant broken in getFirst";
FunctionalPart r = root;
while (r != null && r.left != null) {
r = r.left;
}
return r;
}

/**
* Return the 0-based index part from the subtree given that
* matches the given function.  The mutable inex should be decremented
* for every part we find that matches, so that if we find a match
* when it is zero we return that one.  Once we find the result, we stop
* looking (and stop decrementing).  If there is no such functional part,
* this method returns null.
* @param r subtree to examine, may be null
* @param function kind of part to look for, null means any part
* @param mutableIndex index to look for (0-based); decremented whenever a matching
*   part is encountered in in-order traversal until the desired index.
* @return 0-based matching part, may be null
*/
private static FunctionalPart getHelper(FunctionalPart r, String function, Cell<Integer> mutableIndex) {
if (r == null) return r;
FunctionalPart result = getHelper(r.left, function, mutableIndex);
if (result != null) return result;
if (function == null ||function.equals(r.function)) {
int index = mutableIndex.get();
if (index == 0) return r;
mutableIndex.set(index-1);
}
return getHelper(r.right, function, mutableIndex);
}

/**
*	A method that removes a part with the assistance of a removal helper method
* @param p
* @return ture if part is removed
* @return false if part is not removed
*/
public boolean remove(Part p)
{
if(root == null)return false;

assert wellFormed():"invariant broken at the start of remove";

//check if the part is even in the robot
FunctionalPart traverse = getFirst();
if(traverse.getNext()!=null && !traverse.equals((FunctionalPart)p))
{
traverse = traverse.getNext();
while(traverse !=null)
{
if(traverse.equals((FunctionalPart)p))break;
traverse = traverse.getNext();
}
}
if(traverse != (FunctionalPart)p || traverse == null)return false;

FunctionalPart saveRoot = root;
FunctionalPart holdP = (FunctionalPart) p;
if(holdP.getFunction() ==null)return false;

p = doRemove(root,(FunctionalPart) p);
assert wellFormed():"invariant broken at the end of remove";

//check the root
//check the parent
//if niether is different return false
if(saveRoot != null && !saveRoot.equals(root)){
return true;
}
else if(p != null && p.equals(holdP))
{
return false;
}
else return false;
}

/**
* Change the comparator used to order the robot parts.
* The parts will be reorganized as necessary to accommodate the new order,
* but two parts will be reordered only if necessary.
* (The sorting is "stable".)
* @param comp comparator to use, if null, then henceforth the parts
* can be in any order.
*/
public void setComparator(Comparator<FunctionalPart> comp) {
assert wellFormed() : "invariant broken in setComparator";
if (comp != comparator) {
comparator = comp;
FunctionalPart saved = root;
root = null;
reInsertAll(saved);
}
assert wellFormed() : "invariant broken by setComparator";
}

/**
* Return the number of nodes in this subtree.
* If the subtree isn't null, we use the stored `count' field rather than
* computing the count.
* @param r subtree to count nodes for, must not be null
* @return count of nodes in this subtree
*/
private static int getCount(Node<?> r) {
if (r == null) return 0;
return r.count;
}

/**
* Check that a subtree's count and parent fields are correct.
* @param r subtree to check
* @param p what the parent should be.
* @return whether any problems ere found.  If false is returned than
* exactly one problem has been reported.
*/
private boolean checkTree(Node<T> r, Node<T> p) {
if (r == null) return true;
if (r.parent != p) return report("parent is wrong for " + r);
if (r.count != getCount(r.left) + getCount(r.right) + 1) {
return report("computed count " + r.count + " not consistent with subtrees");
}
return checkTree(r.left, r) && checkTree(r.right, r);
}

/**
* Create a maze of the given size, in which everything is blocked.
* @param rows number of rows, must be positive
* @param columns number of columns, must be positive
*/
public Maze(int rows, int columns) {
if (rows < 1 || columns < 1) throw new IllegalArgumentException("Maze must not be empty");
this.rows = rows;
this.columns = columns;
ropen = new boolean[rows-1][columns];
copen = new boolean[rows][columns-1];
}

/**
* Is this cell open to the left?
* As a special case, the bottom left cell is open to the left
* (this is the maze entry).
* @param i row
* @param j column
* @return whether there is an opening to the left.
* @exception IllegalArgumentException if coordinates out of range.
*/
public boolean isOpenLeft(int i, int j) {
checkCell(i,j);
if(j==0 && rows()-1 == i)return true;//special case

if(j==0) return false;
else if(copen[i][j-1])return true;
else return false;
}

/**
* Is this cell open to the right?
* @param i row
* @param j column
* @return whether there is an opening to the right.
* @exception IllegalArgumentException if coordinates out of range.
*/
public boolean isOpenRight(int i, int j) {

checkCell(i,j);

if(j>=copen[0].length)return false;
else if(copen[i][j])return true;
else return false;
}

/**
* Is this cell open above?
* As special case, the top right cell is open above
* (this is the maze exit).
* @param i row
* @param j column
* @return whether there is an opening going up
* @exception IllegalArgumentException if coordinates out of range.
*/
public boolean isOpenUp(int i, int j) {

checkCell(i,j);
if(i==0&&j==columns()-1)return true;

if(i==0)return false;
else if(ropen[i-1][j])return true;
else return false;
}

/**
* Is this cell open below?
* @param i row
* @param j column
* @return whether there is an opening down down
* @exception IllegalArgumentException if coordinates out of range.
*/
public boolean isOpenDown(int i, int j) {

checkCell(i,j);
if(i>=ropen.length)return false;
else if(ropen[i][j])return true;
else return false;
}

/**
* Read in contents of a maze printed with ASCII graphics from the file.
* The rows and columns are already set (do not read these).
* Example (assuming rows = 3, columns = 4)
* <pre>
* +-+-+-+ +
* |   |   |
* + + + +-+
* | |     |
* + +---+ +
*       | |
* +-----+-+
* </pre>
* @param r buffered reader to read lines from
* @throws IOException if a problem happens with reading
* @throws ParseException if the maze is badly formatted.
* (The implementation is also permitted to simply overlook
* format errors)
*/
public void read(BufferedReader r) throws IOException {
//read() will return the ascii value of the character
String reader;
r.readLine();
for(int i =0; i < rows;i++) {//rows
reader=r.readLine();
for (int j = 2; j < reader.length();j+=2)//columns
{
char ha = reader.charAt(j);
if(ha == ' ')setOpenRight(i,(j/2)-1,true);
}
if(i!=rows-1) {//rows
reader = r.readLine();
for (int j = 1; j < reader.length(); j+=2)
{
char ha =reader.charAt(j);
if(ha == ' ')setOpenDown(i,j/2,true);
}
}

}
}

/**
* Write out the maze in a specific textual and human readable form.
* For example:
* <pre>
* +-+-+-+ +
* |   |   |
* + + + +-+
* | |     |
* + +---+ +
*       | |
* +-----+-+
* </pre>
*
* @param pw print writer to write to, must not be null
*/
public void write(PrintWriter pw) {
int copenCount =0;
int ropenCount=0;
StringBuilder table = new StringBuilder();

for(int i =0; i < rows()*2+1; i++)//change second condition
{
//special cases
if(i ==0)//first line
{
for(int a=0;a < columns()*2+1;a++)
{
if(a == columns()*2-1) table.append(" ");
else if(a%2==0) table.append("+");
else table.append("-");
}
}
else if(i == rows()*2-1)//second to last line
{
for(int b =0;b < columns()*2+1;b++)
{
if(b==0 || b%2==1)table.append(" ");
else{
if(isOpenRight(ropenCount,copenCount))table.append(" ");
else table.append("|");
copenCount++;
}
}
copenCount=0;
}

//Main cases
else if(i%2==1)//copen
{
for(int d=0; d <columns()*2+1;d++)
{
if(d == 0 || d == columns()*2) table.append("|");
else if(d%2==0)
{
if(isOpenRight(ropenCount,copenCount)) table.append(" ");
else table.append("|");
copenCount++;
}
else table.append(" ");
}
copenCount=0;
}
else if(i%2==0)//ropen
{
for (int e = 0; e < columns() * 2 + 1; e++) {
if (e % 2 == 1) {
if (isOpenDown(ropenCount, copenCount)) table.append(" ");
else table.append("-");
copenCount++;
} else table.append("+");
}
ropenCount++;
copenCount = 0;
if(i == rows()*2)
{
table.append("\n");
String finalMaze = table.toString();
pw.write(finalMaze);
}
}
table.append("\n");
}
}

/**
* Clear maze (everything is the same open/closed).
* @param open whether everything should be open (or closed)
*/
public void clear(boolean open) {
for (int i = 0; i < rows; ++i) {
for (int j=0; j < columns; ++j) {
if (i+1 != rows) ropen[i][j] = open;
if (j+1 != columns) copen[i][j] = open;
}
}
}

/**
* Exception thrown by {@link #read} if it notices a problem.
*
*/
public static class ParseException extends IOException {
/**
* Keep Eclipse happy
*/
private static final long serialVersionUID = 1L;

public ParseException(String s) { super(s); }
}

/** Create a cell for row i and column j.
* This is a convenience method for creating new cells,
* since the Java syntax for doing so in a different class is tricky.
* You don't need to use this method.
* @param i row
* @param j column
* @return new Cell(i,j)
*/
public Cell makeCell(int i, int j) {
return new Cell(i,j);
}

/**
* Set the displayed solution to the argument
* @param sd (may be null -- show no solution)
*/
public void setSolution(SolutionDisplay sd) {
solution = sd;
}

/**
* Create a maze solver for this maze.
*
* @param m maze to solve, must not be null
*/
public MazeSolver(Maze m) {
maze = m;
visited = new Cell[maze.rows()][maze.columns()];
}

/**
* Try to find a path, and return a solution display:
* either a path solution display, if a path was found,
* or a visited solution display if no path was found.
*
* @return solution display (must not be null)
*/
public SolutionDisplay findPath() {
int rows = maze.rows();
int columns = maze.columns();
Stack<Maze.Cell> prev = new Stack<Cell>();

Cell cur = maze.makeCell(rows - 1, 0);
prev.push(cur);
visited[rows-1][0] = cur;

Cell look = null;
boolean winner = false;
ArrayList<Cell> path = new ArrayList<>(rows * columns);

int saveSize=pending.size();

boolean noAdded=false;

while (!winner) {
//Special case for if solution is reached
if (cur.row == 0 && cur.column == columns - 1) {
winner = true;
break;
}
noAdded = doPending(cur);
if(pending.isEmpty())break;

look = pending.peek();
if(!noAdded) {
prev = doPrev(prev, cur, look);
}

// If the cell has not been visited then we jump there
if (visited[look.row][look.column] == null) {
cur = pending.pop();
prev.push(cur);
visited[cur.row][cur.column] = cur;
} else pending.pop();

}

if (winner) {

for(int i = prev.search(visited[rows-1][0])-1; i > -1; i--)
{
path.add(0,prev.pop());
}
return new PathSolutionDisplay(maze, path);
} else {
boolean[][] marked = new boolean[rows][columns];
for (int i = 0; i < visited.length; i++) {
for (int j = 0; j < visited[i].length; j++) {
if (visited[i][j] == null) marked[i][j] = false;
else marked[i][j] = true;
}
}
return new VisitedSolutionDisplay(maze, marked);
}
}