/*** Add another player into this player's team by priority order.
* <ul>
* <li> If the other player has higher priority, place it somewhere before this player.
* <li> If the other player has equal priority, it should be placed immediately after this player.
* <li> If the other player has lower priority, place it somewhere after this player.
* </ul>
* It may be necessary to move multiple times forward or multiple times backward (but not both!)
* <p>
* Also, the code must use recursion to traverse the list - no loops are allowed!
* @param p the player to add to our list, must not be null
* @param priority comparator of players in the list, must not be null
*/
public void addInPriority(Player p, Comparator<Player> priority) {
// TODO: Implement this method.  No loops, only recursion
//
// NB: While Team happens to call this method only on the head of the list,
//	   we can't assume all classes that utilize Player will do so. That is why
//	   we must consider all scenarios, including those where this method is
//	   called on a player in the middle or end of the list.

if(priority.compare(p, this) < 0) {
if(next == null) {
p.prev = this;
next = p;
}else if(priority.compare(p, next) > 0) {
p.prev = this;
p.next = next;
next.prev = p;
next = p;
}else {
next.addInPriority(p, priority);
}
}else if(priority.compare(p, this) > 0) {
if(prev == null) {
p.next = this;
prev = p;
}else if(priority.compare(p, prev) < 0) {
p.next = this;
p.prev = prev;
prev.next = p;
prev = p;
}else {
prev.addInPriority(p, priority);
}
}else {//(priority.compare(p, this) == 0)
if(next == null) {
p.prev = this;
next = p;
}else {
p.prev = this;
p.next = next;
next.prev = p;
next = p;
}
}
}